# Refactoring Proposal: Maurer Rose Interpolator v17 (Code Name: "Grounded")

## 1. Executive Summary
The current Maurer Rose Interpolator (v16.1) is a feature-rich prototype built as a single-page application with a monolithic codebase (~1800 lines of JS). While functional, the current architecture (DOM-as-state, monolithic update loop, global variables) makes it difficult to maintain, extend, or test.

This proposal outlines a ground-up rewrite ("v17") to establish a robust, modular, and scalable architecture. This will support the continued expansion of features while maintaining code quality and developer sanity.

## 2. Architectural Goals
1.  **Separation of Concerns**: Strictly separate business logic (math/generation), application state, rendering, and UI handling.
2.  **Centralized State Management**: Move away from "DOM as Source of Truth". Implement a distinct State Store that drives the UI and Renderer.
3.  **Modularity**: Break the application into small, single-purpose ES Modules.
4.  **Scalability**: Ensure new features (e.g., new interpolation methods, new coloring modes) can be added without modifying the core engine.
5.  **Performance Check**: Optimize the rendering pipeline to handle high-vertex counts more efficiently.

## 3. Technology Stack
*   **Language**: Modern JavaScript (ES6+ Modules).
*   **Build Tool**: **Vite**. It provides a fast dev server, HMR (Hot Module Replacement), and efficient bundling, while allowing us to stick to "Vanilla" JS without the overhead of a heavy framework like React or Vue.
*   **Styling**: **Tailwind CSS**.

## 4. Proposed Architecture

### 4.1. Core Modules (The "Engine")
These modules are pure logic and have zero knowledge of the DOM.

*   **`engine/math/`**:
    *   `rhodonea.js`: Pure functions to calculate r = sin(k*theta) points.
    *   `maurer.js`: Functions to generate the polyline points based on d, n.
    *   `lcm.js`: Specialized math for LCM, GCD, prime factorization.
    *   `interpolation.js`: Algorithms for morphing sets of points (Linear, LCM-based, etc.).
*   **`engine/state/`**:
    *   `Store.js`: A simpler Redux-like or Proxy-based state manager. It holds the `paramsA`, `paramsB`, `globalSettings` objects.
    *   `Actions.js`: Defined actions for modifying state (e.g., `UPDATE_ROSE_PARAM`, `SYNC_PARAMS`).

### 4.2. Rendering System
*   **`renderer/`**:
    *   `CanvasRenderer.js`: A class that accepts a Canvas context and a State object, then draws the frame. It handles coordinate system transforms.
    *   `layers/`: Sub-modules for drawing specific parts: `RoseLayer.js`, `CosetsLayer.js`, `UIOverlayLayer.js`.

### 4.3. UI Components (The "Shell")
We will use a lightweight Component pattern (class-based) to manage DOM sections.

*   **`ui/`**:
    *   `RosePanel.js`: A reusable class that manages one "Rose Control Panel". We instantiate this twice (for A and B).
    *   `InterpolationPanel.js`: Manages the center controls.
    *   `NotificationSystem.js`: For toasts/alerts.

### 4.4. Application Entry
*   **`main.js`**: The bootstrapper. It initializes the Store, instantiates the UI components, creates the Renderer, and starts the Animation Loop.

## 5. Directory Structure
```
apps/Maurer_Rose_Interpolator/
├── index.html              # Entry point
├── vite.config.js          # Vite configuration
├── package.json            # Dependencies
├── src/
│   ├── main.js             # Entry logic
│   ├── config/             # Constants and defaults
│   │   └── defaults.js
│   ├── engine/             # Pure Logic
│   │   ├── math/
│   │   │   ├── core.js     # GCD, Primes
│   │   │   ├── geometry.js # Point, Distance
│   │   │   └── maurer.js   # Rose generation
│   │   └── state/
│   │       ├── store.js    # State container
│   │       └── signals.js  # Event bus
│   ├── renderer/           # Canvas Handling
│   │   ├── Renderer.js     # Main render loop
│   │   └── styles/         # Visual styling helpers
│   └── ui/                 # DOM Interaction
│       ├── components/
│       │   ├── Panel.js    # Base class
│       │   ├── RoseSettings.js
│       │   └── InterpControls.js
│       └── utils/
│           └── dom.js      # Helper functions
└── public/                 # Static assets
```

## 6. Migration Strategy
1.  **Setup**: Initialize Vite project in the new directory.
2.  **Extraction (Phase 1)**: Port the math functions from the existing prototype to `src/engine/math`.
3.  **State (Phase 2)**: Design the State schema and Store.
4.  **Renderer (Phase 3)**: Create the `CanvasRenderer` and implement basic drawing.
5.  **UI Wiring (Phase 4)**: Recreate the HTML structure and bind the UI components.
6.  **Feature Parity (Phase 5)**: Re-enable advanced features (Animation, Interpolation, Cosets, Recording).

## 7. Immediate Next Steps
1.  Approve this plan.
2.  Wait for me to initialize the project and begin Phase 1.
