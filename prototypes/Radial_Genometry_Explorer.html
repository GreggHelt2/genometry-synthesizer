<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Figure Animated Geometric Patterns</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; /* Tailwind gray-800 */
            color: #d1d5db; /* Tailwind gray-300 */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
        }
        .top-level-container { /* Wrapper for main content and snapshot strip */
            display: flex;
            width: 100%;
            max-width: calc(1600px + 120px + 1rem); /* Max-width of main + strip width + gap */
            gap: 1rem;
        }
        .content-wrapper { /* For existing main content */
            flex-grow: 1;
            max-width: 1600px;
            display: flex;
            flex-direction: column;
        }
        .main-container {
            display: flex;
            flex-wrap: nowrap; 
            justify-content: flex-start; 
            gap: 1rem; 
            width: 100%;
            overflow-x: auto; 
        }
        .figure-slot-container { 
            background-color: #374151; 
            border-radius: 0.75rem; 
            padding: 1rem; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            display: flex;
            flex-direction: column;
            align-items: center; 
            min-width: 340px; 
            flex-shrink: 0; 
            box-sizing: border-box;
        }

        .overlay-container { 
            background-color: #374151; 
            border-radius: 0.75rem; 
            padding: 1rem; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            display: flex;
            flex-direction: column;
            align-items: center; 
            width: 100%; 
            margin-top: 1rem; 
        }
        
        /* Snapshot Strip Styles */
        .snapshot-strip-container {
            width: 110px; /* Width of the strip */
            flex-shrink: 0;
            background-color: #2d3748; /* Tailwind gray-800 */
            border-radius: 0 0.75rem 0.75rem 0; /* Rounded corners on the right */
            padding: 0.5rem;
            box-shadow: 5px 0 15px -3px rgba(0,0,0,0.2); /* Shadow on the right */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            max-height: calc(100vh - 2rem); /* Adjust based on body padding */
        }
        .snapshot-strip-container h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #e5e7eb;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        .snapshot-save-area-strip {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            width: 100%;
            margin-bottom: 0.5rem;
        }
        .snapshot-save-area-strip input[type="text"] {
            width: 100%;
            background-color: #4b5563;
            color: #e5e7eb;
            border: 1px solid #6b7280;
            border-radius: 0.25rem;
            padding: 0.3rem 0.5rem;
            font-size: 0.8rem;
        }
        #saveSnapshotStripBtn { 
             width: 100%;
        }

        #snapshotImageStrip {
            width: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            flex-grow: 1;
        }
        .snapshot-image-item {
            position: relative; 
            cursor: pointer;
        }
        .snapshot-image-item img {
            width: 80px; 
            height: 80px;
            object-fit: cover;
            border-radius: 0.25rem;
            border: 2px solid #4b5563; 
            transition: border-color 0.2s;
        }
        .snapshot-image-item img:hover {
            border-color: #3b82f6; 
        }

        /* Custom Context Menu */
        #customContextMenu {
            position: absolute;
            background-color: #374151; 
            border: 1px solid #4b5563; 
            border-radius: 0.375rem; 
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            padding: 0.25rem 0;
            z-index: 4000; 
            display: none; 
            min-width: 120px;
        }
        #customContextMenu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        #customContextMenu li {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.875rem;
            color: #d1d5db; 
        }
        #customContextMenu li:hover {
            background-color: #4b5563; 
            color: #f3f4f6; 
        }


        canvas {
            border: 1px solid #4b5563; 
            border-radius: 0.5rem; 
            background-color: #000000; 
            display: block; 
        }
        h1 {
            font-size: 1.875rem; 
            font-weight: 600; 
            margin-bottom: 1.5rem; 
            text-align: center;
            color: #f3f4f6; 
        }
        h2 { 
            font-size: 1.1rem; 
            font-weight: 600; 
            margin-bottom: 0.5rem; 
            color: #e5e7eb; 
        }
        h3 { 
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #e5e7eb;
        }
        .figure-type-selector {
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .figure-type-selector label {
            font-size: 0.9rem;
            color: #d1d5db;
        }
        .figure-type-selector select {
            background-color: #4b5563;
            color: #e5e7eb;
            border: 1px solid #6b7280;
            border-radius: 0.25rem;
            padding: 0.25rem 0.5rem;
        }

        .controls {
            margin-top: 0.75rem; 
            display: grid; 
            grid-template-columns: auto 1fr; 
            gap: 0.4rem 0.8rem; 
            align-items: center;
            width: 100%;
            max-width: 300px; 
        }
        .controls label, .controls .checkbox-label {
            font-size: 0.8rem; 
            justify-self: start; 
            color: #d1d5db; 
        }
        .controls input[type="range"], .controls input[type="number"], .controls select, .controls .styled-button, .controls .preset-display-button {
            width: 100%; 
            justify-self: end;
            accent-color: #3b82f6; 
            background-color: #4b5563; 
            color: #e5e7eb; 
            border: 1px solid #6b7280; 
            border-radius: 0.25rem;
            padding: 0.1rem 0.25rem;
            box-sizing: border-box; 
        }
        .controls select {
            padding: 0.2rem 0.25rem; 
        }
        .controls .styled-button, .controls .preset-display-button { 
            background-color: #2563eb; 
            color: white;
            padding: 0.3rem 0.6rem;
            text-align: center;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .controls .styled-button:hover, .controls .preset-display-button:hover {
            background-color: #1d4ed8; 
        }
        .controls input[type="color"] {
            width: 36px; 
            height: 28px; 
            border: 1px solid #4b5563; 
            padding: 0;
            border-radius: 0.25rem;
            cursor: pointer;
            justify-self: end; 
        }
         .controls .checkbox-container { 
            grid-column: span 2; 
            display: flex;
            align-items: center;
            gap: 0.4rem; 
        }
        .controls input[type="checkbox"] {
             accent-color: #3b82f6; 
        }
        .controls .accordion-header { /* Modified for accordion trigger */
            grid-column: span 2;
            font-size: 0.9rem;
            font-weight: 600;
            color: #9ca3af; 
            margin-top: 0.5rem;
            margin-bottom: 0.2rem;
            border-bottom: 1px solid #4b5563;
            padding-bottom: 0.1rem;
            cursor: pointer;
            transition: background-color 0.2s;
            position: relative; /* For arrow positioning */
            padding-left: 1.7em; /* Space for arrow */
            user-select: none; /* Prevent text selection on click */
        }
        .controls .accordion-header::before {
            content: '►'; /* Collapsed state arrow */
            position: absolute;
            left: 0.5em;
            top: 50%;
            transform: translateY(-50%);
            transition: transform 0.2s ease-in-out;
            font-size: 0.8em;
        }
        .controls .accordion-header.active::before {
            content: '▼'; /* Expanded state arrow */
        }
        .controls .accordion-header:hover {
             background-color: #4b5563; /* Tailwind gray-600 for hover */
        }

        .accordion-content {
            display: none; /* Initially hidden */
            grid-column: span 2; /* Span across both columns of the parent .controls grid */
            /* The grid properties for children are now set directly on this panel */
            grid-template-columns: auto 1fr; 
            gap: 0.4rem 0.8rem; 
            align-items: center; 
            width: 100%;
            padding-top: 0.5rem; 
        }
        .accordion-content.active {
            display: grid; /* Show with grid layout */
        }


        .slider-value-wrapper {
            position: relative;
            width: 100%; 
        }
        .slider-value-wrapper input[type="range"] {
            display: block; 
            width: 100%;
            margin: 0;
        }
        .slider-value-wrapper output {
            position: absolute;
            bottom: 22px; 
            background-color: #6b7280; 
            color: #e5e7eb;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            white-space: nowrap;
            pointer-events: none; 
            transform: translateX(-50%); 
            opacity: 0;
            transition: opacity 0.1s ease-in-out;
            z-index: 10; 
        }
        .slider-value-wrapper:hover output,
        .slider-value-wrapper input[type="range"]:active + output {
            opacity: 1;
        }
        
        #gradientSidebar {
            position: fixed;
            top: 5vh; 
            right: -350px; 
            width: 300px;
            height: auto; 
            max-height: 90vh; 
            background-color: #2d3748; 
            padding: 1rem;
            box-shadow: -5px 0 15px rgba(0,0,0,0.2);
            transition: right 0.3s ease-in-out;
            z-index: 1000;
            overflow-y: auto;
            border-radius: 0.5rem 0 0 0.5rem; 
        }
        #gradientSidebar.visible {
            right: 0;
        }
        #gradientSidebar h4 {
            color: #e5e7eb;
            margin-bottom: 1rem;
            text-align: center;
        }
        #gradientsCanvas {
            width: 100%;
            height: auto; 
            background-color: #1a202c; 
            border-radius: 0.25rem;
            cursor: pointer;
        }
        #closeGradientSidebar {
            background-color: #4a5568; 
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            display: block;
            width: 100%;
            margin-top: 1rem;
        }
        #closeGradientSidebar:hover {
            background-color: #2d3748; 
        }
    </style>
</head>
<body>
    <h1>Animated Geometric Patterns</h1>
    <div class="top-level-container">
        <div class="snapshot-strip-container">
            <h3>Snapshots</h3>
            <div class="snapshot-save-area-strip">
                <input type="text" id="snapshotNameInput" placeholder="Snapshot Name">
                <button id="saveSnapshotStripBtn" class="styled-button">Save Current</button>
            </div>
            <div id="snapshotImageStrip">
                </div>
        </div>
        <div class="content-wrapper">
            <div class="main-container">
                <div class="figure-slot-container">
                    <h2>Figure 1</h2>
                    <div class="figure-type-selector">
                        <label for="figure1Type">Type:</label>
                        <select id="figure1Type">
                            <option value="centeredCircles">Centered Circles</option>
                            <option value="rhodoneaCurve">Rhodonea Curve</option>
                            <option value="epitrochoid">Epitrochoid</option> 
                            <option value="hypotrochoid">Hypotrochoid</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <canvas id="figure1Canvas" width="300" height="300"></canvas>
                    <div class="controls" id="figure1Controls">
                        {/* Controls for Figure 1 will be populated here */}
                    </div>
                </div>

                <div class="figure-slot-container">
                    <h2>Figure 2</h2>
                    <div class="figure-type-selector">
                        <label for="figure2Type">Type:</label>
                        <select id="figure2Type">
                            <option value="centeredCircles">Centered Circles</option>
                            <option value="rhodoneaCurve" selected>Rhodonea Curve</option>
                            <option value="epitrochoid">Epitrochoid</option>
                            <option value="hypotrochoid">Hypotrochoid</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <canvas id="figure2Canvas" width="300" height="300"></canvas>
                    <div class="controls" id="figure2Controls">
                        {/* Controls for Figure 2 will be populated here */}
                    </div>
                </div>

                <div class="figure-slot-container">
                    <h2>Figure 3</h2>
                    <div class="figure-type-selector">
                        <label for="figure3Type">Type:</label>
                        <select id="figure3Type">
                            <option value="centeredCircles">Centered Circles</option>
                            <option value="rhodoneaCurve">Rhodonea Curve</option>
                            <option value="epitrochoid">Epitrochoid</option>
                            <option value="hypotrochoid">Hypotrochoid</option>
                            <option value="none" selected>None</option>
                        </select>
                    </div>
                    <canvas id="figure3Canvas" width="300" height="300"></canvas>
                    <div class="controls" id="figure3Controls">
                        {/* Controls for Figure 3 will be populated here */}
                    </div>
                </div>
            </div>

            <div class="overlay-container">
                <h3>Overlay</h3>
                <canvas id="combinedCanvas" width="600" height="600"></canvas>
                <div class="controls" id="combinedControls">
                     <label for="mainBlendingMode">Main Blending Mode:</label>
                     <select id="mainBlendingMode">
                         <option value="source-over">Normal</option>
                         <option value="lighter">Lighter (Additive)</option>
                         <option value="multiply">Multiply</option>
                         <option value="screen">Screen</option>
                         <option value="overlay">Overlay</option>
                         <option value="darken">Darken</option>
                         <option value="lighten">Lighten</option>
                         <option value="color-dodge">Color Dodge</option>
                         <option value="color-burn">Color Burn</option>
                         <option value="hard-light">Hard Light</option>
                         <option value="soft-light">Soft Light</option>
                         <option value="difference">Difference</option>
                         <option value="exclusion">Exclusion</option>
                         <option value="hue">Hue</option>
                         <option value="saturation">Saturation</option>
                         <option value="color">Color</option>
                         <option value="luminosity">Luminosity</option>
                     </select>
                </div>
            </div>
        </div>
    </div>

    <div id="gradientSidebar">
        <h4>Choose Preset Gradient</h4>
        <canvas id="gradientsCanvas"></canvas>
        <button id="closeGradientSidebar">Close</button>
    </div>

    <div id="customContextMenu">
        <ul>
            <li id="ctxMenuLoad">Load</li>
            <li id="ctxMenuRename">Rename</li>
            <li id="ctxMenuDelete">Delete</li>
        </ul>
    </div>

    <script>
        // Global state variables for figure parameters and canvases
        const figureParams = [{}, {}, {}]; 
        const figureCanvases = [];
        const figureContexts = [];

        // Default parameter configurations for each figure type
        // These are used for initialization and merging when loading snapshots
        const defaultCenteredCirclesParams = {
            type: 'centeredCircles',
            color: '#007bff', 
            baseLineWidth: 2, animateLineWidth: false, lineWidthAnimationSpeed: 0.2, currentLineWidth: 2, lineWidthAmplitudeFactor: 0.5,
            baseRotation: 0, animateRotation: false, reverseRotation: false, rotationSpeed: 0.1, currentRotation: 0,
            showCenterCircle: true, centerRadiusPercent: 50, numOuterCircles: 6,
            baseSizePercent: 75, animateSize: false, sizeAnimationSpeed: 0.2, currentSizePercent: 75, sizeAmplitude: 20,
            blendingMode: 'defer',
            fillLoops: false, fillType: 'solid', fillColor1: '#007bff', fillColor2: '#0056b3', fillOpacity: 1, 
            presetGradient: 'ocean' 
        };

        const defaultRhodoneaParams = {
            type: 'rhodoneaCurve',
            color: '#FF69B4', 
            baseLineWidth: 2, animateLineWidth: false, lineWidthAnimationSpeed: 0.2, currentLineWidth: 2, lineWidthAmplitudeFactor: 0.5,
            n: 3, d: 4,
            baseRotation: 0, animateRotation: false, reverseRotation: false, rotationSpeed: 0.1, currentRotation: 0,
            showCenterCircle: false, centerRadiusPercent: 50,
            baseSizePercent: 75, animateSize: false, sizeAnimationSpeed: 0.2, currentSizePercent: 75, sizeAmplitude: 20,
            steps: 1000, blendingMode: 'defer',
            fillLoops: false, fillType: 'solid', fillColor1: '#FF69B4', fillColor2: '#FFC0CB', fillOpacity: 1,
            presetGradient: 'sunset' 
        };

        const defaultEpitrochoidParams = {
            type: 'epitrochoid',
            color: '#28a745', 
            baseLineWidth: 2, animateLineWidth: false, lineWidthAnimationSpeed: 0.2, currentLineWidth: 2, lineWidthAmplitudeFactor: 0.5,
            R: 30, r: 10, d_param: 20, 
            baseRotation: 0, animateRotation: false, reverseRotation: false, rotationSpeed: 0.1, currentRotation: 0,
            baseSizePercent: 75, animateSize: false, sizeAnimationSpeed: 0.2, currentSizePercent: 75, sizeAmplitude: 20,
            steps: 1000, blendingMode: 'defer',
            fillLoops: false, fillType: 'solid', fillColor1: '#28a745', fillColor2: '#90EE90', fillOpacity: 1,
            presetGradient: 'forest'
        };

        const defaultHypotrochoidParams = {
            type: 'hypotrochoid',
            color: '#FFA500', 
            baseLineWidth: 2, animateLineWidth: false, lineWidthAnimationSpeed: 0.2, currentLineWidth: 2, lineWidthAmplitudeFactor: 0.5,
            R: 50, r: 20, d_param: 30, 
            baseRotation: 0, animateRotation: false, reverseRotation: false, rotationSpeed: 0.1, currentRotation: 0,
            baseSizePercent: 75, animateSize: false, sizeAnimationSpeed: 0.2, currentSizePercent: 75, sizeAmplitude: 20,
            steps: 1000, blendingMode: 'defer',
            fillLoops: false, fillType: 'solid', fillColor1: '#FFA500', fillColor2: '#FFD700', fillOpacity: 1,
            presetGradient: 'fire'
        };
        
        const FIGURE3_DEFAULT_COLOR = '#50BE71'; // Special default color for Figure 3

        // Predefined gradient options
        const presetGradients = [
            { id: 'sunset', name: 'Sunset', stops: [{offset:0, color:'#FFD700'}, {offset:0.5, color:'#FF8C00'}, {offset:1, color:'#FF0000'}] },
            { id: 'ocean', name: 'Ocean', stops: [{offset:0, color:'#00BFFF'}, {offset:0.7, color:'#1E90FF'}, {offset:1, color:'#000080'}] },
            { id: 'forest', name: 'Forest', stops: [{offset:0, color:'#90EE90'}, {offset:0.5, color:'#2E8B57'}, {offset:1, color:'#006400'}] },
            { id: 'nebula', name: 'Nebula', stops: [{offset:0, color:'#DA70D6'}, {offset:0.3, color:'#8A2BE2'}, {offset:0.7, color:'#4B0082'}, {offset:1, color:'#000000'}] },
            { id: 'fire', name: 'Fire', stops: [{offset:0, color:'#FFFF00'}, {offset:0.2, color:'#FFD700'}, {offset:0.6, color:'#FF4500'}, {offset:1, color:'#8B0000'}] },
            { id: 'ice', name: 'Ice', stops: [{offset:0, color:'#E0FFFF'}, {offset:0.5, color:'#AFEEEE'}, {offset:1, color:'#7FFFD4'}] },
            { id: 'rose', name: 'Rose Petals', stops: [{offset:0, color:'#FFC0CB'}, {offset:0.6, color:'#FF69B4'}, {offset:1, color:'#DB7093'}] },
            { id: 'cosmic_lilac', name: 'Cosmic Lilac', stops: [{offset:0, color:'#483D8B'}, {offset:0.5, color:'#9370DB'}, {offset:1, color:'#FFC0CB'}] },
            { id: 'minty_spring', name: 'Minty Spring', stops: [{offset:0, color:'#3CB371'}, {offset:0.6, color:'#98FB98'}, {offset:1, color:'#F0FFF0'}] },
            { id: 'desert_mirage', name: 'Desert Mirage', stops: [{offset:0, color:'#F4A460'}, {offset:0.5, color:'#CD853F'}, {offset:0.8, color:'#A0522D'}, {offset:1, color:'#87CEEB'}] },
            { id: 'volcanic_ash', name: 'Volcanic Ash', stops: [{offset:0, color:'#2F4F4F'}, {offset:0.4, color:'#808080'}, {offset:0.7, color:'#FF4500'}, {offset:1, color:'#DC143C'}] },
            { id: 'coral_reef', name: 'Coral Reef', stops: [{offset:0, color:'#FF7F50'}, {offset:0.5, color:'#40E0D0'}, {offset:1, color:'#FFFFE0'}] },
            { id: 'arctic_dawn', name: 'Arctic Dawn', stops: [{offset:0, color:'#ADD8E6'}, {offset:0.4, color:'#B0E0E6'}, {offset:0.7, color:'#E6E6FA'}, {offset:1, color:'#FFFFFF'}] },
            { id: 'enchanted_forest', name: 'Enchanted Forest', stops: [{offset:0, color:'#006400'}, {offset:0.4, color:'#556B2F'}, {offset:0.7, color:'#20B2AA'}, {offset:1, color:'#008080'}] },
            { id: 'strawberry_kiwi', name: 'Strawberry Kiwi', stops: [{offset:0, color:'#FF4500'}, {offset:0.3, color:'#FFB6C1'}, {offset:0.7, color:'#32CD32'}, {offset:1, color:'#ADFF2F'}] },
            { id: 'vintage_wine', name: 'Vintage Wine', stops: [{offset:0, color:'#800000'}, {offset:0.5, color:'#B22222'}, {offset:0.8, color:'#DAA520'}, {offset:1, color:'#FFD700'}] },
            { id: 'galaxy_swirl', name: 'Galaxy Swirl', stops: [{offset:0, color:'#000033'}, {offset:0.3, color:'#4B0082'}, {offset:0.6, color:'#FF00FF'}, {offset:0.8, color:'#00FFFF'}, {offset:1, color:'#1E1E1E'}] },
            { id: 'emerald_isle', name: 'Emerald Isle', stops: [{offset:0, color:'#006A4E'}, {offset:0.25, color:'#00A86B'}, {offset:0.5, color:'#50C878'}, {offset:0.75, color:'#98FF98'}, {offset:1, color:'#C1FFC1'}] },
            { id: 'twilight_sky', name: 'Twilight Sky', stops: [{offset:0, color:'#191970'}, {offset:0.3, color:'#4682B4'}, {offset:0.6, color:'#B0C4DE'}, {offset:0.8, color:'#FFDAB9'}, {offset:1, color:'#FFA07A'}] },
            { id: 'autumn_leaves', name: 'Autumn Leaves', stops: [{offset:0, color:'#8B4513'}, {offset:0.25, color:'#A0522D'}, {offset:0.5, color:'#D2691E'}, {offset:0.75, color:'#FF8C00'}, {offset:1, color:'#FFD700'}] }
        ];

        // Global DOM element references and animation state
        let mainBlendingModeInputElem; 
        let overlayParams = { mainBlendingMode: 'source-over' }; // Default overlay params
        let gradientSidebarElem;
        let gradientsCanvasElem;
        let gradientsCtxElem;
        let closeGradientSidebarButtonElem;
        let snapshotNameInput;
        let saveSnapshotStripBtn; 
        let snapshotImageStripDiv; 
        let customContextMenuElem; 
        let currentContextMenuSnapshotId = null; 

        let lastTimestamp = 0;
        let accumulatedTime = 0;
        let activeFigureIndexForGradientChoice = 0; 
        let isBatchUpdatingUI = false; // Flag to pause rendering during batch UI updates

        // Initialize figure canvases and contexts
        for (let i = 0; i < 3; i++) {
            figureCanvases[i] = document.getElementById(`figure${i+1}Canvas`);
            figureContexts[i] = figureCanvases[i].getContext('2d');
        }
        const combinedCanvas = document.getElementById('combinedCanvas');
        const combinedCtx = combinedCanvas.getContext('2d');
        
        /**
         * Helper function to get a deep copy of default parameters for a given figure type.
         * @param {string} type - The type of the figure.
         * @returns {object} A deep copy of the default parameters.
         */
        function getDefaultParams(type) {
            switch (type) {
                case 'centeredCircles': return JSON.parse(JSON.stringify(defaultCenteredCirclesParams));
                case 'rhodoneaCurve': return JSON.parse(JSON.stringify(defaultRhodoneaParams));
                case 'epitrochoid': return JSON.parse(JSON.stringify(defaultEpitrochoidParams));
                case 'hypotrochoid': return JSON.parse(JSON.stringify(defaultHypotrochoidParams));
                case 'none': 
                default: 
                    return { type: 'none' }; // Basic structure for 'none' or unknown
            }
        }

        // --- Utility Functions ---
        function gcd(a, b) { // Greatest Common Divisor
            if (b === 0) return a;
            return gcd(b, a % b);
        }
        
        function hexToRgba(hex, alpha) { // Convert HEX color to RGBA
            if (!hex || hex.length < 7) return `rgba(0,0,0,${alpha})`; 
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            if (isNaN(r) || isNaN(g) || isNaN(b)) return `rgba(0,0,0,${alpha})`; 
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // --- UI Control Creation Functions ---
        function createLabel(forId, text) {
            const label = document.createElement('label');
            label.htmlFor = forId;
            label.textContent = text;
            return label;
        }

        function createRangeInput(id, min, max, value, step) {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-value-wrapper';
            const input = document.createElement('input');
            input.type = 'range';
            input.id = id;
            input.min = String(min); 
            input.max = String(max); 
            input.step = String(step);

            const numDecimalPlaces = String(step).includes('.') ? String(step).split('.')[1].length : 0;
            const stringValue = Number(value).toFixed(numDecimalPlaces);
            input.value = stringValue; 

            const output = document.createElement('output');
            output.htmlFor = id;
            output.id = `${id}-value`;
            output.textContent = stringValue; 

            wrapper.appendChild(input);
            wrapper.appendChild(output);
            input.addEventListener('input', (event) => {
                updateSliderOutputPosition(event.target);
            });
            return wrapper;
        }
        
        function createNumberInput(id, min, max, value, step) {
            const input = document.createElement('input');
            input.type = 'number';
            input.id = id;
            input.min = min;
            input.max = max;
            input.value = value;
            input.step = step;
            return input;
        }

        function createColorInput(id, value) {
            const input = document.createElement('input');
            input.type = 'color';
            input.id = id;
            input.value = value;
            return input;
        }

        function createCheckbox(id, labelText, checked) {
            const container = document.createElement('div');
            container.className = 'checkbox-container';
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.id = id;
            input.checked = checked;
            const label = document.createElement('label');
            label.htmlFor = id;
            label.className = 'checkbox-label';
            label.textContent = labelText;
            container.appendChild(input);
            container.appendChild(label);
            return container;
        }

        function createSelect(id, options, selectedValue) { 
            const select = document.createElement('select');
            select.id = id;
            options.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.text; 
                if (opt.value === selectedValue) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            return select;
        }
        
        function createButton(id, text, onClickHandler) { 
            const button = document.createElement('button');
            button.type = 'button';
            button.id = id;
            button.textContent = text;
            button.className = 'styled-button'; 
            button.addEventListener('click', onClickHandler);
            return button;
        }

        function createSubheading(text, isAccordionHeader = false) { // Added isAccordionHeader flag
            const h4 = document.createElement('h4');
            h4.textContent = text;
            if (isAccordionHeader) {
                h4.classList.add('accordion-header');
            }
            return h4;
        }
        
        const blendingModeOptions = [
            { value: 'defer', text: 'Defer to Main' }, { value: 'source-over', text: 'Normal' },
            { value: 'lighter', text: 'Lighter (Additive)' }, { value: 'multiply', text: 'Multiply' },
            { value: 'screen', text: 'Screen' }, { value: 'overlay', text: 'Overlay' },
            { value: 'darken', text: 'Darken' }, { value: 'lighten', text: 'Lighten' },
            { value: 'color-dodge', text: 'Color Dodge' }, { value: 'color-burn', text: 'Color Burn' },
            { value: 'hard-light', text: 'Hard Light' }, { value: 'soft-light', text: 'Soft Light' },
            { value: 'difference', text: 'Difference' }, { value: 'exclusion', text: 'Exclusion' },
            { value: 'hue', text: 'Hue' }, { value: 'saturation', text: 'Saturation' },
            { value: 'color', text: 'Color' }, { value: 'luminosity', text: 'Luminosity' }
        ];

        const fillTypeOptions = [ 
            { value: 'solid', text: 'Solid' }, { value: 'linear', text: '2-Color Linear' },
            { value: 'radial', text: '2-Color Radial' }, { value: 'preset', text: 'Preset Gradient' }
        ];
        
        /**
         * Populates the control panel for a given figure based on its type and parameters.
         * @param {number} figureIndex - The index of the figure (0, 1, or 2).
         * @param {string} figureType - The type of the figure (e.g., 'centeredCircles').
         */
        function populateControls(figureIndex, figureType) {
            const controlsDiv = document.getElementById(`figure${figureIndex + 1}Controls`);
            controlsDiv.innerHTML = ''; // Clear existing controls
            const params = figureParams[figureIndex]; // Use the already updated/merged params

            if (figureType === 'none' || !params) return; 

            // Helper function to create an accordion section
            function createAccordionSection(title, controlsArray, isInitiallyOpen = false) {
                const header = createSubheading(title, true); // Add class for accordion header
                const panel = document.createElement('div');
                panel.className = 'accordion-content';
                if (isInitiallyOpen) {
                    header.classList.add('active');
                    panel.classList.add('active');
                }

                controlsArray.forEach(controlWrapper => {
                    if (controlWrapper.label && controlWrapper.id) {
                         panel.appendChild(createLabel(controlWrapper.id, controlWrapper.label));
                         panel.appendChild(controlWrapper.element);
                    } else {
                        // For elements without a separate label (like checkboxes or full-width buttons)
                        // Ensure they span both columns if they are direct children of the panel
                        if (controlWrapper.element.classList.contains('checkbox-container') || 
                            controlWrapper.element.tagName === 'BUTTON' || 
                            (controlWrapper.element.id && controlWrapper.element.id.includes('choosePresetContainer'))) {
                             // These elements are already designed to span or are handled by their own structure
                        }
                        panel.appendChild(controlWrapper.element);
                    }
                });

                header.addEventListener('click', () => {
                    header.classList.toggle('active'); 
                    panel.classList.toggle('active'); 
                    
                    if (panel.classList.contains('active')) {
                        panel.querySelectorAll('input[type="range"]').forEach(slider => {
                            updateSliderOutputPosition(slider);
                        });
                    }
                });
                controlsDiv.appendChild(header);
                controlsDiv.appendChild(panel);
            }
            
            // Blending Mode (Top-level general setting for the figure)
            controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-blendingMode`, 'Blending Mode:'));
            controlsDiv.appendChild(createSelect(`figure${figureIndex+1}-blendingMode`, blendingModeOptions, params.blendingMode));

            // --- Shape Section ---
            const shapeControlsArray = [];
            if (figureType === 'centeredCircles' || figureType === 'rhodoneaCurve') {
                shapeControlsArray.push({ element: createCheckbox(`figure${figureIndex+1}-toggleCenterCircle`, 'Show Center Circle', params.showCenterCircle) });
                shapeControlsArray.push({ label: 'Center Circle Size:', id: `figure${figureIndex+1}-centerRadiusPercent`, element: createRangeInput(`figure${figureIndex+1}-centerRadiusPercent`, 0, 100, params.centerRadiusPercent, 1) });
            }
            if (figureType === 'centeredCircles') {
                shapeControlsArray.push({ label: 'Outer Circles:', id: `figure${figureIndex+1}-numOuterCircles`, element: createNumberInput(`figure${figureIndex+1}-numOuterCircles`, 2, 24, params.numOuterCircles, 1) });
            } else if (figureType === 'rhodoneaCurve') {
                shapeControlsArray.push({ label: 'n (numerator):', id: `figure${figureIndex+1}-n`, element: createNumberInput(`figure${figureIndex+1}-n`, 1, 100, params.n, 1) });
                shapeControlsArray.push({ label: 'd (denominator):', id: `figure${figureIndex+1}-d`, element: createNumberInput(`figure${figureIndex+1}-d`, 1, 100, params.d, 1) });
            } else if (figureType === 'epitrochoid' || figureType === 'hypotrochoid') {
                shapeControlsArray.push({ label: 'R (Fixed Circle):', id: `figure${figureIndex+1}-R`, element: createRangeInput(`figure${figureIndex+1}-R`, 1, 100, params.R, 1) });
                shapeControlsArray.push({ label: 'r (Rolling Circle):', id: `figure${figureIndex+1}-r`, element: createRangeInput(`figure${figureIndex+1}-r`, 1, 100, params.r, 1) });
                shapeControlsArray.push({ label: 'd (Distance):', id: `figure${figureIndex+1}-d_param`, element: createRangeInput(`figure${figureIndex+1}-d_param`, 1, 150, params.d_param, 1) });
            }
            if (shapeControlsArray.length > 0) createAccordionSection('Shape', shapeControlsArray, true); // Open Shape by default


            // --- Line Section ---
            const lineControlsArray = [
                { label: 'Color:', id: `figure${figureIndex+1}-color`, element: createColorInput(`figure${figureIndex+1}-color`, params.color) },
                { label: 'Base:', id: `figure${figureIndex+1}-baseLineWidth`, element: createRangeInput(`figure${figureIndex+1}-baseLineWidth`, 0.5, 40, params.baseLineWidth, 0.1) },
                { element: createCheckbox(`figure${figureIndex+1}-animateLineWidth`, 'Animate', params.animateLineWidth) },
                { label: 'Speed:', id: `figure${figureIndex+1}-lineWidthAnimationSpeed`, element: createRangeInput(`figure${figureIndex+1}-lineWidthAnimationSpeed`, 0.01, 1, params.lineWidthAnimationSpeed, 0.01) }
            ];
            createAccordionSection('Line', lineControlsArray);
            
            // --- Fill Section ---
            if (figureType === 'rhodoneaCurve' || figureType === 'epitrochoid' || figureType === 'hypotrochoid' || figureType === 'centeredCircles') {
                const fillControlsArray = [
                    { element: createCheckbox(`figure${figureIndex+1}-fillLoops`, 'Fill Shape', params.fillLoops) },
                    { label: 'Fill Type:', id: `figure${figureIndex+1}-fillType`, element: createSelect(`figure${figureIndex+1}-fillType`, fillTypeOptions, params.fillType) }
                ];

                const choosePresetButtonContainer = document.createElement('div');
                choosePresetButtonContainer.id = `figure${figureIndex + 1}-choosePresetContainer`;
                choosePresetButtonContainer.style.gridColumn = 'span 2'; 
                choosePresetButtonContainer.style.marginTop = '0.25rem'; 
                const choosePresetButton = createButton(`figure${figureIndex+1}-choosePresetBtn`, 'Choose Preset Gradient...', () => {
                    activeFigureIndexForGradientChoice = figureIndex;
                    renderGradientStrips();
                    gradientSidebarElem.classList.add('visible');
                });
                choosePresetButtonContainer.appendChild(choosePresetButton);
                fillControlsArray.push({element: choosePresetButtonContainer});
                
                const presetSelect = createSelect(`figure${figureIndex+1}-presetGradient`, presetGradients.map(g => ({ value: g.id, text: g.name })), params.presetGradient);
                presetSelect.style.display = 'none'; 
                fillControlsArray.push({element: presetSelect}); 

                fillControlsArray.push({ label: 'Fill Color 1:', id: `figure${figureIndex+1}-fillColor1`, element: createColorInput(`figure${figureIndex+1}-fillColor1`, params.fillColor1) });
                fillControlsArray.push({ label: 'Fill Color 2:', id: `figure${figureIndex+1}-fillColor2`, element: createColorInput(`figure${figureIndex+1}-fillColor2`, params.fillColor2) });
                fillControlsArray.push({ label: 'Fill Opacity:', id: `figure${figureIndex+1}-fillOpacity`, element: createRangeInput(`figure${figureIndex+1}-fillOpacity`, 0, 1, params.fillOpacity, 0.01) });
                
                createAccordionSection('Fill', fillControlsArray);
                updateFigureFillControlsVisibility(figureIndex); 
            }
            
            // --- Size Section ---
            const sizeControlsArray = [
                { label: 'Base Size:', id: `figure${figureIndex+1}-baseSizePercent`, element: createRangeInput(`figure${figureIndex+1}-baseSizePercent`, 0, 100, params.baseSizePercent, 1) },
                { element: createCheckbox(`figure${figureIndex+1}-animateSize`, 'Animate', params.animateSize) },
                { label: 'Speed:', id: `figure${figureIndex+1}-sizeAnimationSpeed`, element: createRangeInput(`figure${figureIndex+1}-sizeAnimationSpeed`, 0.01, 1, params.sizeAnimationSpeed, 0.01) }
            ];
            createAccordionSection('Size', sizeControlsArray);

            // --- Rotation Section ---
            const rotationControlsArray = [
                { label: 'Degrees:', id: `figure${figureIndex+1}-baseRotation`, element: createRangeInput(`figure${figureIndex+1}-baseRotation`, 0, 360, params.baseRotation / (Math.PI / 180), 1) },
                { element: createCheckbox(`figure${figureIndex+1}-animateRotation`, 'Animate', params.animateRotation) },
                { element: createCheckbox(`figure${figureIndex+1}-reverseRotation`, 'Reverse', params.reverseRotation) },
                { label: 'Speed:', id: `figure${figureIndex+1}-rotationSpeed`, element: createRangeInput(`figure${figureIndex+1}-rotationSpeed`, 0.01, 1, params.rotationSpeed, 0.01) }
            ];
            createAccordionSection('Rotation', rotationControlsArray);
            
            addEventListenersToControls(figureIndex);
            setTimeout(() => { 
                controlsDiv.querySelectorAll('.accordion-content.active input[type="range"]').forEach(updateSliderOutputPosition);
            }, 0);
        }

        /**
         * Updates the visibility of fill-related controls based on the selected fill type.
         * @param {number} figureIndex - The index of the figure.
         */
        function updateFigureFillControlsVisibility(figureIndex) { 
            const prefix = `figure${figureIndex + 1}-`;
            const params = figureParams[figureIndex];
            if (!params || (params.type !== 'rhodoneaCurve' && params.type !== 'epitrochoid' && params.type !== 'hypotrochoid' && params.type !== 'centeredCircles')) return;

            const showSolid = params.fillType === 'solid';
            const showGradientColors = params.fillType === 'linear' || params.fillType === 'radial';
            const showPresetButton = params.fillType === 'preset';

            const fillColor1El = document.getElementById(`${prefix}fillColor1`);
            const fillColor1LabelEl = fillColor1El?.previousElementSibling; 
            const fillColor2El = document.getElementById(`${prefix}fillColor2`);
            const fillColor2LabelEl = fillColor2El?.previousElementSibling; 
            const choosePresetContainerEl = document.getElementById(`${prefix}choosePresetContainer`); 
            
            if(fillColor1El) fillColor1El.style.display = (showSolid || showGradientColors) ? '' : 'none';
            if(fillColor1LabelEl) fillColor1LabelEl.style.display = (showSolid || showGradientColors) ? '' : 'none';
            if(fillColor2El) fillColor2El.style.display = showGradientColors ? '' : 'none';
            if(fillColor2LabelEl) fillColor2LabelEl.style.display = showGradientColors ? '' : 'none';
            
            if(choosePresetContainerEl) choosePresetContainerEl.style.display = showPresetButton ? 'grid' : 'none'; 
            
            if (showSolid && fillColor1LabelEl) {
                fillColor1LabelEl.textContent = 'Fill Color:';
            } else if (fillColor1LabelEl) {
                fillColor1LabelEl.textContent = 'Fill Color 1:';
            }
        }
        
        /**
         * Updates the position and text of the output element associated with a range slider.
         * @param {HTMLInputElement} slider - The range input element.
         */
        function updateSliderOutputPosition(slider) {
            if (!slider) return; // Guard against null slider
            const wrapper = slider.parentElement;
            if (!wrapper || !wrapper.classList.contains('slider-value-wrapper')) return;
            const output = wrapper.querySelector('output');
            if (output) {
                const value = parseFloat(slider.value); // Read the current value from the slider
                const step = parseFloat(slider.step) || 0.01; // Get step, default if not present or invalid
                const numDecimalPlaces = String(step).includes('.') ? String(step).split('.')[1].length : 0;
                
                output.textContent = value.toFixed(numDecimalPlaces);

                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                const percent = (max === min) ? 0 : (value - min) / (max - min); 
                const sliderWidth = slider.offsetWidth;
                const thumbWidth = 16; 
                let outputLeft = percent * (sliderWidth - thumbWidth) + (thumbWidth / 2); 
                
                output.style.left = `${outputLeft}px`;
            }
        }

        /**
         * Adds event listeners to all controls for a specific figure.
         * @param {number} figureIndex - The index of the figure.
         */
        function addEventListenersToControls(figureIndex) {
            const prefix = `figure${figureIndex + 1}-`;
            const addListener = (id, eventType, handler) => {
                const element = document.getElementById(id);
                if (element) {
                    // Element is fresh from populateControls, so just add listener
                    element.addEventListener(eventType, handler);
                    if (element.type === 'range') {
                        // Ensure the output is also updated on input
                        element.addEventListener('input', () => updateSliderOutputPosition(element));
                    }
                } else {
                    // console.warn(`Element with ID ${id} not found for adding listener.`);
                }
            };

            addListener(`${prefix}color`, 'input', () => updateFigureParams(figureIndex));
            addListener(`${prefix}blendingMode`, 'change', () => updateFigureParams(figureIndex)); 
            addListener(`${prefix}baseLineWidth`, 'input', () => updateFigureParams(figureIndex));
            addListener(`${prefix}animateLineWidth`, 'change', () => updateFigureParams(figureIndex));
            addListener(`${prefix}lineWidthAnimationSpeed`, 'input', () => updateFigureParams(figureIndex));
            addListener(`${prefix}baseRotation`, 'input', () => updateFigureParams(figureIndex));
            addListener(`${prefix}animateRotation`, 'change', () => updateFigureParams(figureIndex));
            addListener(`${prefix}reverseRotation`, 'change', () => updateFigureParams(figureIndex)); 
            addListener(`${prefix}rotationSpeed`, 'input', () => updateFigureParams(figureIndex));
            
            if (figureParams[figureIndex] && figureParams[figureIndex].type !== 'epitrochoid' && figureParams[figureIndex].type !== 'hypotrochoid') {
                addListener(`${prefix}toggleCenterCircle`, 'change', () => updateFigureParams(figureIndex));
                addListener(`${prefix}centerRadiusPercent`, 'input', () => updateFigureParams(figureIndex));
            }

            addListener(`${prefix}baseSizePercent`, 'input', () => updateFigureParams(figureIndex));
            addListener(`${prefix}animateSize`, 'change', () => updateFigureParams(figureIndex));
            addListener(`${prefix}sizeAnimationSpeed`, 'input', () => updateFigureParams(figureIndex));

            if (figureParams[figureIndex] && (figureParams[figureIndex].type === 'centeredCircles' || figureParams[figureIndex].type === 'rhodoneaCurve' || figureParams[figureIndex].type === 'epitrochoid' || figureParams[figureIndex].type === 'hypotrochoid')) {
                addListener(`${prefix}fillLoops`, 'change', () => updateFigureParams(figureIndex));
                addListener(`${prefix}fillType`, 'change', () => { 
                    updateFigureParams(figureIndex); // Update state first
                    updateFigureFillControlsVisibility(figureIndex); // Then update UI based on new state
                });
                addListener(`${prefix}fillColor1`, 'input', () => updateFigureParams(figureIndex));
                addListener(`${prefix}fillColor2`, 'input', () => updateFigureParams(figureIndex));
                addListener(`${prefix}fillOpacity`, 'input', () => {
                    updateFigureParams(figureIndex);
                });
                
                if (figureParams[figureIndex].type === 'rhodoneaCurve') {
                    addListener(`${prefix}n`, 'input', () => updateFigureParams(figureIndex));
                    addListener(`${prefix}d`, 'input', () => updateFigureParams(figureIndex));
                } else if (figureParams[figureIndex].type === 'epitrochoid' || figureParams[figureIndex].type === 'hypotrochoid') {
                    addListener(`${prefix}R`, 'input', () => updateFigureParams(figureIndex));
                    addListener(`${prefix}r`, 'input', () => updateFigureParams(figureIndex));
                    addListener(`${prefix}d_param`, 'input', () => updateFigureParams(figureIndex));
                } else if (figureParams[figureIndex].type === 'centeredCircles') {
                     addListener(`${prefix}numOuterCircles`, 'input', () => updateFigureParams(figureIndex));
                }
            }
        }
        
        /**
         * Updates the JavaScript state (figureParams) from the UI control values for a specific figure.
         * @param {number} figureIndex - The index of the figure.
         */
        function updateFigureParams(figureIndex) {
            const params = figureParams[figureIndex];
            const prefix = `figure${figureIndex + 1}-`;

            if (!params || params.type === 'none') return; // Ensure params object exists

            // Helper to get value from element, providing a default if element not found
            const getValue = (id, defaultValue, parser = val => val) => {
                const el = document.getElementById(id);
                return el ? parser(el.value) : defaultValue;
            };
            const getChecked = (id, defaultValue) => {
                const el = document.getElementById(id);
                return el ? el.checked : defaultValue;
            };

            params.color = getValue(`${prefix}color`, params.color);
            params.blendingMode = getValue(`${prefix}blendingMode`, params.blendingMode); 
            params.baseLineWidth = getValue(`${prefix}baseLineWidth`, params.baseLineWidth, parseFloat);
            params.animateLineWidth = getChecked(`${prefix}animateLineWidth`, params.animateLineWidth);
            params.lineWidthAnimationSpeed = getValue(`${prefix}lineWidthAnimationSpeed`, params.lineWidthAnimationSpeed, parseFloat);
            params.baseRotation = getValue(`${prefix}baseRotation`, params.baseRotation / (Math.PI/180) , parseFloat) * Math.PI / 180;
            params.animateRotation = getChecked(`${prefix}animateRotation`, params.animateRotation);
            params.reverseRotation = getChecked(`${prefix}reverseRotation`, params.reverseRotation); 
            params.rotationSpeed = getValue(`${prefix}rotationSpeed`, params.rotationSpeed, parseFloat);
            
            if (params.type !== 'epitrochoid' && params.type !== 'hypotrochoid') {
                params.showCenterCircle = getChecked(`${prefix}toggleCenterCircle`, params.showCenterCircle);
                params.centerRadiusPercent = getValue(`${prefix}centerRadiusPercent`, params.centerRadiusPercent, parseInt);
            }

            params.baseSizePercent = getValue(`${prefix}baseSizePercent`, params.baseSizePercent, parseInt);
            params.animateSize = getChecked(`${prefix}animateSize`, params.animateSize);
            params.sizeAnimationSpeed = getValue(`${prefix}sizeAnimationSpeed`, params.sizeAnimationSpeed, parseFloat);

            if (params.type === 'centeredCircles' || params.type === 'rhodoneaCurve' || params.type === 'epitrochoid' || params.type === 'hypotrochoid') {
                params.fillLoops = getChecked(`${prefix}fillLoops`, params.fillLoops);
                params.fillType = getValue(`${prefix}fillType`, params.fillType); // This should correctly get the value from the select
                params.fillColor1 = getValue(`${prefix}fillColor1`, params.fillColor1);
                params.fillColor2 = getValue(`${prefix}fillColor2`, params.fillColor2);
                params.fillOpacity = getValue(`${prefix}fillOpacity`, params.fillOpacity, parseFloat);
                const presetSelect = document.getElementById(`${prefix}presetGradient`); 
                if (presetSelect) params.presetGradient = presetSelect.value;

                if (params.type === 'centeredCircles') {
                    params.numOuterCircles = getValue(`${prefix}numOuterCircles`, params.numOuterCircles, parseInt);
                } else if (params.type === 'rhodoneaCurve') {
                    params.n = getValue(`${prefix}n`, params.n, parseInt);
                    params.d = getValue(`${prefix}d`, params.d, parseInt);
                    if (params.d === 0) params.d = 1; 
                } else { // Epitrochoid or Hypotrochoid
                    params.R = getValue(`${prefix}R`, params.R, parseInt);
                    params.r = getValue(`${prefix}r`, params.r, parseInt);
                    params.d_param = getValue(`${prefix}d_param`, params.d_param, parseInt);
                    if (params.r === 0) params.r = 1; 
                }
            }
        }

        // Event listener for figure type selectors
        for (let i = 0; i < 3; i++) {
            document.getElementById(`figure${i+1}Type`).addEventListener('change', function() {
                const newType = this.value;
                const oldParams = JSON.parse(JSON.stringify(figureParams[i])); // Deep copy of old common params

                // Get new defaults, then overlay common old params
                let newDefaultSpecificParams = getDefaultParams(newType);
                
                if (newType !== 'none') {
                     figureParams[i] = { 
                        ...newDefaultSpecificParams, // Start with new type's defaults
                        // Carry over common animation/visual properties if they existed
                        animateRotation: oldParams.animateRotation !== undefined ? oldParams.animateRotation : newDefaultSpecificParams.animateRotation,
                        reverseRotation: oldParams.reverseRotation !== undefined ? oldParams.reverseRotation : newDefaultSpecificParams.reverseRotation,
                        rotationSpeed: oldParams.rotationSpeed !== undefined ? oldParams.rotationSpeed : newDefaultSpecificParams.rotationSpeed,
                        baseRotation: oldParams.baseRotation !== undefined ? oldParams.baseRotation : newDefaultSpecificParams.baseRotation,
                        animateSize: oldParams.animateSize !== undefined ? oldParams.animateSize : newDefaultSpecificParams.animateSize,
                        sizeAnimationSpeed: oldParams.sizeAnimationSpeed !== undefined ? oldParams.sizeAnimationSpeed : newDefaultSpecificParams.sizeAnimationSpeed,
                        baseSizePercent: oldParams.baseSizePercent !== undefined ? oldParams.baseSizePercent : newDefaultSpecificParams.baseSizePercent,
                        animateLineWidth: oldParams.animateLineWidth !== undefined ? oldParams.animateLineWidth : newDefaultSpecificParams.animateLineWidth,
                        lineWidthAnimationSpeed: oldParams.lineWidthAnimationSpeed !== undefined ? oldParams.lineWidthAnimationSpeed : newDefaultSpecificParams.lineWidthAnimationSpeed,
                        baseLineWidth: oldParams.baseLineWidth !== undefined ? oldParams.baseLineWidth : newDefaultSpecificParams.baseLineWidth,
                        lineWidthAmplitudeFactor: oldParams.lineWidthAmplitudeFactor !== undefined ? oldParams.lineWidthAmplitudeFactor : newDefaultSpecificParams.lineWidthAmplitudeFactor,
                        color: oldParams.color !== undefined ? oldParams.color : newDefaultSpecificParams.color, // Keep old color if set
                        blendingMode: oldParams.blendingMode !== undefined ? oldParams.blendingMode : 'defer',
                        // Carry over fill options if they existed
                        fillLoops: oldParams.fillLoops !== undefined ? oldParams.fillLoops : newDefaultSpecificParams.fillLoops,
                        fillType: oldParams.fillType !== undefined ? oldParams.fillType : newDefaultSpecificParams.fillType,
                        fillColor1: oldParams.fillColor1 !== undefined ? oldParams.fillColor1 : newDefaultSpecificParams.fillColor1,
                        fillColor2: oldParams.fillColor2 !== undefined ? oldParams.fillColor2 : newDefaultSpecificParams.fillColor2,
                        fillOpacity: oldParams.fillOpacity !== undefined ? oldParams.fillOpacity : newDefaultSpecificParams.fillOpacity,
                        presetGradient: oldParams.presetGradient !== undefined ? oldParams.presetGradient : newDefaultSpecificParams.presetGradient,
                        type: newType // Ensure the type is correctly set to the new type
                    };
                } else {
                    figureParams[i] = { type: 'none' }; // Reset to 'none'
                }
                
                // Special color handling for Figure 3 or if color was a default from another type
                if (i === 2 && newType !== 'none') {
                     figureParams[i].color = FIGURE3_DEFAULT_COLOR;
                } else if (newType !== 'none' && figureParams[i].color === getDefaultParams(oldParams.type)?.color && figureParams[i].color !== newDefaultSpecificParams.color) {
                    // If the color was the default of the *previous* type, and it's different from the new type's default, update it.
                    figureParams[i].color = newDefaultSpecificParams.color;
                }


                populateControls(i, newType);
                // No need to call updateFigureParams here, populateControls uses the already updated figureParams[i]
            });
        }
        
        // --- Drawing Functions ---
        // (drawCenteredCirclesInternal, drawRhodoneaCurveInternal, drawEpitrochoidInternal, drawHypotrochoidInternal remain largely the same as provided before)
        // These functions take ctx, canvasWidth, canvasHeight, and params as arguments
        // and draw the respective figure without clearing the canvas or handling animation updates.

        function drawCenteredCirclesInternal(ctx, canvasWidth, canvasHeight, params) { 
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const currentOuterRadius = (params.currentSizePercent / 100) * (canvasWidth / 4); 

            ctx.lineWidth = params.currentLineWidth;
            ctx.save(); 
            ctx.translate(centerX, centerY);
            ctx.rotate(params.currentRotation); 
            ctx.translate(-centerX, -centerY);

            const figurePath = new Path2D(); 

            if (params.showCenterCircle) {
                const figureRadius = 2 * currentOuterRadius; 
                const actualCenterRadius = (params.centerRadiusPercent / 100) * figureRadius;
                if (actualCenterRadius > 0) {
                    figurePath.moveTo(centerX + actualCenterRadius, centerY); 
                    figurePath.arc(centerX, centerY, actualCenterRadius, 0, 2 * Math.PI);
                }
            }

            if (currentOuterRadius > 0 && params.numOuterCircles > 0) {
                for (let i = 0; i < params.numOuterCircles; i++) { 
                    const angle = (2 * Math.PI / params.numOuterCircles) * i; 
                    const circleX = centerX + currentOuterRadius * Math.cos(angle);
                    const circleY = centerY + currentOuterRadius * Math.sin(angle);
                    figurePath.moveTo(circleX + currentOuterRadius, circleY); 
                    figurePath.arc(circleX, circleY, currentOuterRadius, 0, 2 * Math.PI);
                }
            }
            
            if (params.fillLoops && (params.showCenterCircle || params.numOuterCircles > 0)) {
                let figureEffectiveRadius = 0;
                if (params.numOuterCircles > 0) {
                    figureEffectiveRadius = 2 * currentOuterRadius;
                } else if (params.showCenterCircle) {
                    const tempOuterRadiusForCalc = (params.baseSizePercent / 100) * (canvasWidth / 4); 
                    const figureRadius = 2 * tempOuterRadiusForCalc; 
                    figureEffectiveRadius = (params.centerRadiusPercent / 100) * figureRadius;
                }


                if (figureEffectiveRadius > 0) {
                    if (params.fillType === 'solid') {
                        ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                    } else if (params.fillType === 'linear') {
                        const gradient = ctx.createLinearGradient(centerX - figureEffectiveRadius, centerY, centerX + figureEffectiveRadius, centerY); 
                        gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                        gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                        ctx.fillStyle = gradient;
                    } else if (params.fillType === 'radial') {
                        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, figureEffectiveRadius); 
                        gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                        gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                        ctx.fillStyle = gradient;
                    } else if (params.fillType === 'preset') {
                        const preset = presetGradients.find(p => p.id === params.presetGradient);
                        if (preset) {
                            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, figureEffectiveRadius);
                            preset.stops.forEach(stop => {
                                gradient.addColorStop(stop.offset, hexToRgba(stop.color, params.fillOpacity));
                            });
                            ctx.fillStyle = gradient;
                        } else { 
                            ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity); // Fallback
                        }
                    }
                    ctx.fill(figurePath, "evenodd");
                }
            }

            ctx.strokeStyle = params.color; 
            ctx.stroke(figurePath); 
            ctx.restore(); 
        }

        function drawRhodoneaCurveInternal(ctx, canvasWidth, canvasHeight, params) {
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const current_scale_a = (params.currentSizePercent / 100) * (canvasWidth / 2);
            
            if (params.d === 0) return; 
            const kVal = params.n / params.d; 

            ctx.lineWidth = params.currentLineWidth;
            ctx.save(); 
            ctx.translate(centerX, centerY);
            ctx.rotate(params.currentRotation); 
            ctx.translate(-centerX, -centerY);

            const figurePath = new Path2D();
            const maxTheta = 2 * Math.PI * params.d;
            const numSteps = Math.max(1000, 200 * params.d); 
            let firstPoint = true;
            for (let i = 0; i <= numSteps; i++) {
                const theta = (i / numSteps) * maxTheta;
                const r_val = current_scale_a * Math.cos(kVal * theta); // r is a keyword in JS, use r_val
                const x = centerX + r_val * Math.cos(theta);
                const y = centerY + r_val * Math.sin(theta);
                if (firstPoint) {
                    figurePath.moveTo(x, y);
                    firstPoint = false;
                } else {
                    figurePath.lineTo(x, y);
                }
            }
            figurePath.closePath(); 

            if (params.fillLoops && current_scale_a > 0) {
                if (params.fillType === 'solid') {
                    ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                } else if (params.fillType === 'linear') {
                    const gradient = ctx.createLinearGradient(centerX - current_scale_a, centerY, centerX + current_scale_a, centerY);
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'radial') {
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, current_scale_a);
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'preset') {
                    const preset = presetGradients.find(p => p.id === params.presetGradient);
                    if (preset) {
                        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, current_scale_a);
                        preset.stops.forEach(stop => {
                            gradient.addColorStop(stop.offset, hexToRgba(stop.color, params.fillOpacity));
                        });
                        ctx.fillStyle = gradient;
                    } else { 
                        ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity); // Fallback
                    }
                }
                ctx.fill(figurePath, "evenodd");
            }
            
            if (current_scale_a > 0) {
                ctx.strokeStyle = params.color; 
                ctx.stroke(figurePath);
            }

            if (params.showCenterCircle && params.centerRadiusPercent >= 0) { 
                ctx.strokeStyle = params.color; 
                ctx.lineWidth = params.currentLineWidth; 
                ctx.beginPath(); // Separate path for center circle stroke
                const rhodoneaFigureRadius = current_scale_a;
                const centerCircleRadiusToDraw = (params.centerRadiusPercent / 100) * rhodoneaFigureRadius;
                ctx.arc(centerX, centerY, Math.min(centerCircleRadiusToDraw, canvasWidth / 2), 0, 2 * Math.PI);
                ctx.stroke();
            }
            ctx.restore(); 
        }

        function drawEpitrochoidInternal(ctx, canvasWidth, canvasHeight, params) {
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const sumOfRadiiForScale = params.R + params.r + params.d_param;
            if (sumOfRadiiForScale === 0) return;
            const scaleFactor = ((params.currentSizePercent / 100) * (canvasWidth / 2)) / sumOfRadiiForScale;
            
            const R_draw = params.R * scaleFactor;
            const r_draw = params.r * scaleFactor;
            const d_draw = params.d_param * scaleFactor;
            if (r_draw === 0) return;

            ctx.lineWidth = params.currentLineWidth;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(params.currentRotation);
            
            const figurePath = new Path2D();
            const commonDivisor = gcd(Math.round(params.R), Math.round(params.r));
            const maxTheta = 2 * Math.PI * (params.r / commonDivisor); 
            const numSteps = Math.max(1000, 300 * Math.abs(params.r / commonDivisor));

            let firstPoint = true;
            for (let i = 0; i <= numSteps; i++) {
                const t = (i / numSteps) * maxTheta;
                const x = (R_draw + r_draw) * Math.cos(t) - d_draw * Math.cos(((R_draw + r_draw) / r_draw) * t);
                const y = (R_draw + r_draw) * Math.sin(t) - d_draw * Math.sin(((R_draw + r_draw) / r_draw) * t);
                if (firstPoint) { figurePath.moveTo(x, y); firstPoint = false; } else { figurePath.lineTo(x, y); }
            }
            figurePath.closePath();

            if (params.fillLoops) { 
                const fillRadius = Math.max(R_draw + r_draw, d_draw);
                if (params.fillType === 'solid') {
                    ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                } else if (params.fillType === 'linear') {
                    const gradient = ctx.createLinearGradient(-fillRadius, 0, fillRadius, 0); 
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'radial') {
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, fillRadius); 
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'preset') {
                    const preset = presetGradients.find(p => p.id === params.presetGradient);
                    if (preset) {
                        const gradient = ctx.createRadialGradient(0,0,0, 0,0, fillRadius);
                        preset.stops.forEach(stop => {
                            gradient.addColorStop(stop.offset, hexToRgba(stop.color, params.fillOpacity));
                        });
                        ctx.fillStyle = gradient;
                    } else { 
                        ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity); // Fallback
                    }
                }
                ctx.fill(figurePath, "evenodd");
            }
            ctx.strokeStyle = params.color;
            ctx.stroke(figurePath);
            ctx.restore();
        }
        
        function drawHypotrochoidInternal(ctx, canvasWidth, canvasHeight, params) {
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const characteristicSizeForScale = Math.abs(params.R - params.r) + params.d_param; 
            if (characteristicSizeForScale === 0 && params.r === 0) return; 

            const scaleBase = characteristicSizeForScale > 0 ? characteristicSizeForScale : params.r;
            if (scaleBase === 0) return;

            const scaleFactor = ((params.currentSizePercent / 100) * (canvasWidth / 2)) / scaleBase;

            const R_draw = params.R * scaleFactor;
            const r_draw = params.r * scaleFactor;
            const d_draw = params.d_param * scaleFactor;
            if (r_draw === 0) return;

            ctx.lineWidth = params.currentLineWidth;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(params.currentRotation);
            
            const figurePath = new Path2D(); 

            const commonDivisor = gcd(Math.round(params.R), Math.round(params.r));
            const maxTheta = 2 * Math.PI * (params.r / commonDivisor); 
            const numSteps = Math.max(1000, 300 * Math.abs(params.r / commonDivisor));

            let firstPoint = true;
            for (let i = 0; i <= numSteps; i++) {
                const t = (i / numSteps) * maxTheta;
                const x = (R_draw - r_draw) * Math.cos(t) + d_draw * Math.cos(((R_draw - r_draw) / r_draw) * t);
                const y = (R_draw - r_draw) * Math.sin(t) - d_draw * Math.sin(((R_draw - r_draw) / r_draw) * t);
                 if (firstPoint) { figurePath.moveTo(x, y); firstPoint = false; } else { figurePath.lineTo(x, y); }
            }
            figurePath.closePath();

            if (params.fillLoops) { 
                const fillRadius = Math.max(R_draw, d_draw);
                 if (params.fillType === 'solid') {
                    ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                } else if (params.fillType === 'linear') {
                    const gradient = ctx.createLinearGradient(-fillRadius, 0, fillRadius, 0); 
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'radial') {
                    const gradient = ctx.createRadialGradient(0,0,0, 0,0, fillRadius); 
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'preset') {
                    const preset = presetGradients.find(p => p.id === params.presetGradient);
                    if (preset) {
                         const gradient = ctx.createRadialGradient(0,0,0, 0,0, fillRadius);
                        preset.stops.forEach(stop => {
                            gradient.addColorStop(stop.offset, hexToRgba(stop.color, params.fillOpacity));
                        });
                        ctx.fillStyle = gradient;
                    } else { 
                        ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity); // Fallback
                    }
                }
                ctx.fill(figurePath, "evenodd");
            }
            ctx.strokeStyle = params.color;
            ctx.stroke(figurePath);
            ctx.restore();
        }

        /**
         * Main animation loop. Updates figure parameters based on animation settings
         * and redraws all canvases.
         * @param {DOMHighResTimeStamp} timestamp - The current time.
         */
        function animateFigures(timestamp) {
            // If batch updating UI (e.g., loading snapshot), skip drawing this frame
            if (isBatchUpdatingUI) {
                requestAnimationFrame(animateFigures); // Still request next frame to resume smoothly
                return;
            }

            // Calculate delta time for animations
            const currentDeltaTime = (timestamp - (lastTimestamp || timestamp)) / 1000; // Handles first frame by making deltaTime 0
            lastTimestamp = timestamp;
            accumulatedTime += currentDeltaTime;

            // Animate and draw individual figures
            for (let i = 0; i < 3; i++) {
                const params = figureParams[i];
                const ctx = figureContexts[i];
                const canvas = figureCanvases[i];

                if (!params || params.type === 'none') { // Added check for params existence
                    if (ctx && canvas) ctx.clearRect(0,0, canvas.width, canvas.height); 
                    continue;
                }

                // Update animated parameters
                if (params.animateRotation) {
                    const direction = params.reverseRotation ? -1 : 1;
                    params.currentRotation = params.baseRotation + (direction * accumulatedTime * params.rotationSpeed * 2 * Math.PI);
                } else {
                    params.currentRotation = params.baseRotation;
                }
                if (params.animateSize) {
                    const oscillation = params.sizeAmplitude * Math.sin(accumulatedTime * params.sizeAnimationSpeed * 2 * Math.PI);
                    params.currentSizePercent = params.baseSizePercent + oscillation;
                    params.currentSizePercent = Math.max(0, Math.min(100, params.currentSizePercent)); 
                } else {
                    params.currentSizePercent = params.baseSizePercent;
                }
                if (params.animateLineWidth) {
                    const amplitude = params.baseLineWidth * params.lineWidthAmplitudeFactor; 
                    const oscillation = amplitude * Math.sin(accumulatedTime * params.lineWidthAnimationSpeed * 2 * Math.PI); 
                    params.currentLineWidth = params.baseLineWidth + oscillation; 
                    params.currentLineWidth = Math.max(0.1, params.currentLineWidth); 
                } else {
                    params.currentLineWidth = params.baseLineWidth; 
                }

                // Draw the figure on its individual canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (params.type === 'centeredCircles') {
                    drawCenteredCirclesInternal(ctx, canvas.width, canvas.height, params);
                } else if (params.type === 'rhodoneaCurve') {
                    drawRhodoneaCurveInternal(ctx, canvas.width, canvas.height, params);
                } else if (params.type === 'epitrochoid') {
                    drawEpitrochoidInternal(ctx, canvas.width, canvas.height, params);
                } else if (params.type === 'hypotrochoid') {
                    drawHypotrochoidInternal(ctx, canvas.width, canvas.height, params);
                }
            }
            
            // Draw figures onto the combined overlay canvas
            combinedCtx.clearRect(0, 0, combinedCanvas.width, combinedCanvas.height);
            let firstActiveFigureDrawn = false;
            for (let i = 0; i < 3; i++) {
                const params = figureParams[i];
                if (!params || params.type === 'none') continue; // Added check for params existence

                let effectiveBlendingMode = 'source-over';
                if (!firstActiveFigureDrawn) {
                    firstActiveFigureDrawn = true;
                } else {
                    if (params.blendingMode === 'defer') {
                        effectiveBlendingMode = overlayParams.mainBlendingMode;
                    } else {
                        effectiveBlendingMode = params.blendingMode;
                    }
                }
                
                combinedCtx.globalCompositeOperation = effectiveBlendingMode;
                
                // Re-use internal drawing functions for the combined canvas
                if (params.type === 'centeredCircles') {
                    drawCenteredCirclesInternal(combinedCtx, combinedCanvas.width, combinedCanvas.height, params);
                } else if (params.type === 'rhodoneaCurve') {
                    drawRhodoneaCurveInternal(combinedCtx, combinedCanvas.width, combinedCanvas.height, params);
                } else if (params.type === 'epitrochoid') {
                    drawEpitrochoidInternal(combinedCtx, combinedCanvas.width, combinedCanvas.height, params);
                } else if (params.type === 'hypotrochoid') {
                    drawHypotrochoidInternal(combinedCtx, combinedCanvas.width, combinedCanvas.height, params);
                }
            }
            combinedCtx.globalCompositeOperation = 'source-over'; // Reset to default

            requestAnimationFrame(animateFigures); 
        }
        
        /**
         * Renders the preset gradient strips in the sidebar.
         */
        function renderGradientStrips() {
            const stripHeight = 30;
            gradientsCanvasElem.height = presetGradients.length * stripHeight; 
            gradientsCanvasElem.width = 280; // Width of the sidebar canvas
            gradientsCtxElem.clearRect(0, 0, gradientsCanvasElem.width, gradientsCanvasElem.height); 
            const currentParams = figureParams[activeFigureIndexForGradientChoice];
            const opacity = (currentParams && typeof currentParams.fillOpacity === 'number') ? currentParams.fillOpacity : 0.3; 

            presetGradients.forEach((preset, index) => {
                const y = index * stripHeight; 
                const gradient = gradientsCtxElem.createLinearGradient(0, y, gradientsCanvasElem.width, y); 
                
                preset.stops.forEach(stop => {
                    gradient.addColorStop(stop.offset, hexToRgba(stop.color, opacity)); 
                });
                gradientsCtxElem.fillStyle = gradient; 
                gradientsCtxElem.fillRect(0, y, gradientsCanvasElem.width, stripHeight); 

                gradientsCtxElem.fillStyle = '#FFFFFF'; 
                gradientsCtxElem.font = '12px Inter';
                gradientsCtxElem.textAlign = 'left';
                gradientsCtxElem.textBaseline = 'middle';
                gradientsCtxElem.fillText(preset.name, 10, y + stripHeight / 2); 
            });
        }

        /**
         * Resizes all canvases based on their container sizes and redraws.
         */
        function resizeAndDrawAll() {
            let individualCanvasWidth = 300; 

            const figureSlotContainers = document.querySelectorAll('.figure-slot-container');
            if (figureSlotContainers.length > 0) {
                const firstSlotContainer = figureSlotContainers[0];
                const containerStyle = window.getComputedStyle(firstSlotContainer);
                const containerPaddingLeft = parseFloat(containerStyle.paddingLeft);
                const containerPaddingRight = parseFloat(containerStyle.paddingRight);
                let newWidth = firstSlotContainer.clientWidth - containerPaddingLeft - containerPaddingRight;
                individualCanvasWidth = Math.max(newWidth, 100); 

                figureSlotContainers.forEach((container, index) => {
                    const canvas = figureCanvases[index]; 
                    if(canvas) {
                        canvas.width = individualCanvasWidth;
                        canvas.height = individualCanvasWidth; 
                    }
                });
            }
            
            if (combinedCanvas) { 
                const overlayContainer = document.querySelector('.overlay-container');
                const containerStyle = window.getComputedStyle(overlayContainer);
                const containerPaddingLeft = parseFloat(containerStyle.paddingLeft);
                const containerPaddingRight = parseFloat(containerStyle.paddingRight);
                let combinedWidth = overlayContainer.clientWidth - containerPaddingLeft - containerPaddingRight;
                
                combinedWidth = Math.min(individualCanvasWidth * 2, combinedWidth); // Cap at twice individual or container width
                combinedWidth = Math.max(combinedWidth, 150); // Minimum size

                combinedCanvas.width = combinedWidth; 
                combinedCanvas.height = combinedWidth; 
            }
            // Update slider output positions as their container might have resized
            document.querySelectorAll('input[type="range"]').forEach(updateSliderOutputPosition);
            // No need to explicitly call animateFigures here, as it runs continuously
        }

        // --- Initialization on Window Load ---
        window.onload = () => {
            // Get DOM element references
            mainBlendingModeInputElem = document.getElementById('mainBlendingMode');
            gradientSidebarElem = document.getElementById('gradientSidebar');
            gradientsCanvasElem = document.getElementById('gradientsCanvas');
            gradientsCtxElem = gradientsCanvasElem.getContext('2d');
            closeGradientSidebarButtonElem = document.getElementById('closeGradientSidebar');
            snapshotNameInput = document.getElementById('snapshotNameInput'); 
            saveSnapshotStripBtn = document.getElementById('saveSnapshotStripBtn'); 
            snapshotImageStripDiv = document.getElementById('snapshotImageStrip'); 
            customContextMenuElem = document.getElementById('customContextMenu');

            // Initialize overlay parameters
            overlayParams.mainBlendingMode = mainBlendingModeInputElem.value;
            
            // Event listener for main blending mode
            mainBlendingModeInputElem.addEventListener('change', () => { 
                overlayParams.mainBlendingMode = mainBlendingModeInputElem.value; 
            });

            // Event listener for closing gradient sidebar
            closeGradientSidebarButtonElem.addEventListener('click', () => {
                gradientSidebarElem.classList.remove('visible');
            });
            
            // Event listener for selecting a gradient from the sidebar
            gradientsCanvasElem.addEventListener('click', function(event) {
                const rect = gradientsCanvasElem.getBoundingClientRect();
                const y = event.offsetY; 
                const stripHeight = 30; 
                let clickedIndex = -1;

                for (let i = 0; i < presetGradients.length; i++) {
                    const stripTop = i * stripHeight;
                    const stripBottom = stripTop + stripHeight;
                    if (y >= stripTop && y < stripBottom) {
                        clickedIndex = i;
                        break;
                    }
                }

                if (clickedIndex !== -1) {
                    const selectedPresetId = presetGradients[clickedIndex].id;
                    if (figureParams[activeFigureIndexForGradientChoice]) { // Ensure params object exists
                        figureParams[activeFigureIndexForGradientChoice].presetGradient = selectedPresetId;
                        
                        const presetSelectElement = document.getElementById(`figure${activeFigureIndexForGradientChoice + 1}-presetGradient`);
                        if(presetSelectElement) presetSelectElement.value = selectedPresetId;

                        updateFigureParams(activeFigureIndexForGradientChoice); 
                    }
                }
            });

            // Snapshot functionality event listeners
            saveSnapshotStripBtn.addEventListener('click', saveSnapshot);
            renderSavedSnapshots(); // Load and display any existing snapshots

            // Hide custom context menu on click outside or Escape key
            document.addEventListener('click', (event) => {
                if (customContextMenuElem.style.display === 'block' && !customContextMenuElem.contains(event.target)) {
                    customContextMenuElem.style.display = 'none';
                }
            });
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    customContextMenuElem.style.display = 'none';
                }
            });

            // Initialize each figure based on its default selected type in HTML
            for (let i = 0; i < 3; i++) {
                const typeSelector = document.getElementById(`figure${i+1}Type`);
                const initialType = typeSelector.value;
                
                // Start with the defaults for the selected type
                figureParams[i] = getDefaultParams(initialType);

                // Apply specific initial color overrides if necessary
                if (i === 2 && initialType !== 'none') { 
                    figureParams[i].color = FIGURE3_DEFAULT_COLOR;
                } else if (i === 1 && initialType === 'rhodoneaCurve') { 
                     // Figure 2 is Rhodonea by default, its color is already set by getDefaultParams
                } else if (i === 0 && initialType === 'centeredCircles') {
                    // Figure 1 is Centered Circles by default, color set by getDefaultParams
                }
                // Add other specific overrides if needed based on initial HTML selections

                populateControls(i, initialType);
                // updateFigureParams(i) is not needed here, as populateControls sets UI from figureParams
            }
            
            resizeAndDrawAll(); // Initial resize and draw
            
            lastTimestamp = performance.now(); // Set initial timestamp for animation
            requestAnimationFrame(animateFigures); // Start the animation loop

            // Handle window resize
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    resizeAndDrawAll();
                    // Slider output positions might need re-calculation on resize
                    document.querySelectorAll('input[type="range"]').forEach(updateSliderOutputPosition);
                }, 100); 
            });
        };

        // --- Snapshot Functions ---
        function saveSnapshot() {
            let name = snapshotNameInput.value.trim();
            if (!name) {
                name = `Snapshot ${new Date().toLocaleString()}`;
            }

            // Create a thumbnail from the combined canvas
            const thumbnailCanvas = document.createElement('canvas');
            thumbnailCanvas.width = 80; // Thumbnail size
            thumbnailCanvas.height = 80;
            const thumbCtx = thumbnailCanvas.getContext('2d');
            thumbCtx.drawImage(combinedCanvas, 0, 0, 80, 80);
            const thumbnailDataUrl = thumbnailCanvas.toDataURL('image/jpeg', 0.5); // Use JPEG for smaller size

            const snapshot = {
                id: Date.now(),
                name: name,
                timestamp: new Date().toLocaleString(),
                figureParams: JSON.parse(JSON.stringify(figureParams)), // Deep copy
                overlayParams: JSON.parse(JSON.stringify(overlayParams)), // Deep copy
                thumbnail: thumbnailDataUrl
            };

            let snapshots = JSON.parse(localStorage.getItem('geometricPatternSnapshots')) || [];
            snapshots.unshift(snapshot); // Add new snapshot to the beginning
            try {
                localStorage.setItem('geometricPatternSnapshots', JSON.stringify(snapshots));
                renderSavedSnapshots();
                snapshotNameInput.value = ''; // Clear input field
            } catch (e) {
                console.error("Error saving to localStorage:", e);
                alert("Could not save snapshot. Storage might be full.");
            }
        }

        function loadSnapshot(snapshotId) {
            isBatchUpdatingUI = true; // PAUSE rendering
            console.log(`Attempting to load snapshot ID: ${snapshotId}`);
            const snapshots = JSON.parse(localStorage.getItem('geometricPatternSnapshots')) || [];
            const loadedSnapshotData = snapshots.find(s => s.id === snapshotId);

            if (loadedSnapshotData) {
                console.log('Snapshot data found:', loadedSnapshotData);
                
                // Restore and Merge figureParams
                const loadedFigParamsData = JSON.parse(JSON.stringify(loadedSnapshotData.figureParams || [{},{},{}]));
                for (let i = 0; i < 3; i++) { 
                    const loadedFigureConfig = loadedFigParamsData[i] || {type: 'none'}; // Ensure loadedFigureConfig exists
                    // Get current defaults for the type specified in the snapshot
                    let defaultParamsForType = getDefaultParams(loadedFigureConfig.type || 'none'); 
                    // Merge: Loaded data overwrites defaults, new defaults from current app version are added
                    figureParams[i] = { ...defaultParamsForType, ...loadedFigureConfig };
                }
                console.log('Global figureParams merged and restored:', figureParams);

                // Restore and Merge overlayParams
                const defaultMainOverlayParams = { mainBlendingMode: 'source-over' }; // Define current default overlay
                overlayParams = { ...defaultMainOverlayParams, ...(JSON.parse(JSON.stringify(loadedSnapshotData.overlayParams || {}))) };
                console.log('Global overlayParams merged and restored:', overlayParams);
                
                if (mainBlendingModeInputElem) {
                    mainBlendingModeInputElem.value = overlayParams.mainBlendingMode;
                }
                
                // Update UI for each figure
                for(let i=0; i<3; i++) {
                    console.log(`Restoring UI for Figure ${i+1}`);
                    const typeSelector = document.getElementById(`figure${i+1}Type`);
                    if (typeSelector && figureParams[i]) {
                        typeSelector.value = figureParams[i].type; 
                        console.log(`Figure ${i+1} type selector value set to: ${figureParams[i].type}`);
                        populateControls(i, figureParams[i].type); 
                    } else if (typeSelector) { // Fallback if figureParams[i] is somehow undefined
                         typeSelector.value = 'none';
                         populateControls(i, 'none');
                    }
                }
                console.log('Snapshot load and UI update sequence complete.');
            } else {
                console.error("Snapshot not found:", snapshotId);
            }
            isBatchUpdatingUI = false; // RESUME rendering
        }

        function renameSnapshot(snapshotId) {
            console.log("Rename function called for ID:", snapshotId); 
            let snapshots = JSON.parse(localStorage.getItem('geometricPatternSnapshots')) || [];
            const snapshotIndex = snapshots.findIndex(s => s.id === snapshotId);
            if (snapshotIndex === -1) {
                console.error("Snapshot to rename not found:", snapshotId);
                return;
            }
            
            const newName = prompt("Enter new name for the snapshot:", snapshots[snapshotIndex].name);
            
            if (newName !== null) { // User clicked OK
                if (newName.trim() !== "") {
                    snapshots[snapshotIndex].name = newName.trim();
                    localStorage.setItem('geometricPatternSnapshots', JSON.stringify(snapshots));
                    renderSavedSnapshots();
                    console.log("Snapshot renamed and list updated.");
                } else {
                     console.log("Rename not performed: name was empty.");
                }
            } else {
                 console.log("Rename cancelled by user (prompt returned null).");
            }
        }

        function deleteSnapshot(snapshotId) {
            console.log("[Delete] Attempting to delete snapshot ID:", snapshotId);
            if (snapshotId === null || snapshotId === undefined) {
                console.error("[Delete] snapshotId is null or undefined. Aborting.");
                return;
            }

            let snapshots = JSON.parse(localStorage.getItem('geometricPatternSnapshots')) || [];
            console.log("[Delete] Snapshots before filtering:", JSON.parse(JSON.stringify(snapshots))); 

            const snapshotToDelete = snapshots.find(s => s.id === snapshotId);
            
            if (!snapshotToDelete) {
                 console.error("[Delete] Snapshot to delete not found in current list for ID:", snapshotId);
                return;
            }
            console.log("[Delete] Snapshot found for deletion:", snapshotToDelete.name);
            
            if (confirm(`Are you sure you want to delete snapshot "${snapshotToDelete.name}"?`)) {
                console.log("[Delete] Deletion confirmed by user for:", snapshotToDelete.name);
                const initialLength = snapshots.length;
                snapshots = snapshots.filter(s => s.id !== snapshotId);
                const newLength = snapshots.length;
                console.log(`[Delete] Snapshots filtered. Initial count: ${initialLength}, New count: ${newLength}`);

                if (initialLength === newLength && initialLength > 0) { // Check if length > 0 to avoid warning on empty list
                    console.warn("[Delete] Filter did not remove any snapshots. Check ID matching. snapshotId:", snapshotId, "Type:", typeof snapshotId);
                    snapshots.forEach(s => console.log("Existing s.id:", s.id, "Type:", typeof s.id));
                }

                try {
                    localStorage.setItem('geometricPatternSnapshots', JSON.stringify(snapshots));
                    console.log("[Delete] Snapshots saved to localStorage. New count:", snapshots.length);
                } catch (e) {
                    console.error("[Delete] Error saving to localStorage after delete:", e);
                    alert("Could not update snapshots after deletion. Storage might be an issue.");
                    renderSavedSnapshots(); 
                    return; 
                }
                renderSavedSnapshots(); 
                console.log("[Delete] Snapshot strip re-rendered.");
            } else {
                console.log("[Delete] Deletion cancelled by user for snapshot:", snapshotToDelete.name);
            }
        }


        function renderSavedSnapshots() {
            snapshotImageStripDiv.innerHTML = ''; // Clear current snapshots
            const snapshots = JSON.parse(localStorage.getItem('geometricPatternSnapshots')) || [];

            if (snapshots.length === 0) {
                const p = document.createElement('p');
                p.className = 'text-gray-400 text-sm text-center w-full';
                p.textContent = 'No snapshots yet.';
                snapshotImageStripDiv.appendChild(p);
                return;
            }

            snapshots.forEach(snapshot => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'snapshot-image-item';
                
                const img = document.createElement('img');
                img.src = snapshot.thumbnail;
                img.alt = snapshot.name;
                img.title = `${snapshot.name}\nSaved: ${snapshot.timestamp}`; // Tooltip
                
                itemDiv.appendChild(img);

                // Double-click to load
                itemDiv.addEventListener('dblclick', () => {
                    console.log(`Double-clicked snapshot ID: ${snapshot.id}, Name: ${snapshot.name}`);
                    loadSnapshot(snapshot.id);
                });
                // Right-click for context menu
                itemDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    currentContextMenuSnapshotId = snapshot.id;
                    customContextMenuElem.style.top = `${e.pageY}px`; 
                    customContextMenuElem.style.left = `${e.pageX}px`; 
                    customContextMenuElem.style.display = 'block';
                });
                snapshotImageStripDiv.appendChild(itemDiv);
            });
        }

        // Context Menu Event Listeners
        document.getElementById('ctxMenuLoad').addEventListener('click', () => {
            const idToLoad = currentContextMenuSnapshotId; 
            customContextMenuElem.style.display = 'none'; 
            if (idToLoad) {
                console.log(`Context menu: Loading snapshot ID: ${idToLoad}`);
                loadSnapshot(idToLoad);
            }
        });
        document.getElementById('ctxMenuRename').addEventListener('click', () => {
            const idToRename = currentContextMenuSnapshotId;
            customContextMenuElem.style.display = 'none';
            if (idToRename) {
                console.log(`Context menu: Renaming snapshot ID: ${idToRename}`);
                renameSnapshot(idToRename);
            }
        });
        document.getElementById('ctxMenuDelete').addEventListener('click', () => {
            const idToDelete = currentContextMenuSnapshotId;
            customContextMenuElem.style.display = 'none';
            if (idToDelete) {
                console.log(`Context menu: Deleting snapshot ID: ${idToDelete}`);
                deleteSnapshot(idToDelete);
            }
        });
    </script>
</body>
</html>
