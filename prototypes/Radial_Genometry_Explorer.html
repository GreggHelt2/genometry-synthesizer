<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Figure Animated Geometric Patterns</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1f2937; 
            color: #d1d5db; 
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 1rem;
            box-sizing: border-box;
        }
        .top-level-container { /* Wrapper for main content and snapshot strip */
            display: flex;
            width: 100%;
            max-width: calc(1600px + 120px + 1rem); /* Max-width of main + strip width + gap */
            gap: 1rem;
        }
        .content-wrapper { /* For existing main content */
            flex-grow: 1;
            max-width: 1600px;
            display: flex; 
            flex-direction: column;
        }
        .main-container {
            display: flex;
            flex-wrap: nowrap; 
            justify-content: flex-start; 
            gap: 1rem; 
            width: 100%;
            overflow-x: auto; 
        }
        .figure-slot-container { 
            background-color: #374151; 
            border-radius: 0.75rem; 
            padding: 1rem; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            display: flex;
            flex-direction: column;
            align-items: center; 
            min-width: 340px; 
            flex-shrink: 0; 
            box-sizing: border-box;
        }

        .overlay-container { 
            background-color: #374151; 
            border-radius: 0.75rem; 
            padding: 1rem; 
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); 
            display: flex;
            flex-direction: column;
            align-items: center; 
            width: 100%; 
            margin-top: 1rem; 
        }
        
        /* Snapshot Strip Styles */
        .snapshot-strip-container {
            width: 110px; /* Width of the strip */
            flex-shrink: 0;
            background-color: #2d3748; /* Tailwind gray-800 */
            border-radius: 0 0.75rem 0.75rem 0; /* Rounded corners on the right */
            padding: 0.5rem;
            box-shadow: 5px 0 15px -3px rgba(0,0,0,0.2); /* Shadow on the right */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            max-height: calc(100vh - 2rem); /* Adjust based on body padding */
        }
        .snapshot-strip-container h3 {
            font-size: 1rem;
            font-weight: 600;
            color: #e5e7eb;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        .snapshot-save-area-strip {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            width: 100%;
            margin-bottom: 0.5rem;
        }
        .snapshot-save-area-strip input[type="text"] {
            width: 100%;
            background-color: #4b5563;
            color: #e5e7eb;
            border: 1px solid #6b7280;
            border-radius: 0.25rem;
            padding: 0.3rem 0.5rem;
            font-size: 0.8rem;
        }
        #saveSnapshotStripBtn { 
             width: 100%;
        }

        #snapshotImageStrip {
            width: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            flex-grow: 1;
        }
        .snapshot-image-item {
            position: relative; 
            cursor: pointer;
        }
        .snapshot-image-item img {
            width: 80px; 
            height: 80px;
            object-fit: cover;
            border-radius: 0.25rem;
            border: 2px solid #4b5563; 
            transition: border-color 0.2s;
        }
        .snapshot-image-item img:hover {
            border-color: #3b82f6; 
        }

        /* Custom Context Menu */
        #customContextMenu {
            position: absolute;
            background-color: #374151; 
            border: 1px solid #4b5563; 
            border-radius: 0.375rem; 
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            padding: 0.25rem 0;
            z-index: 4000; 
            display: none; 
            min-width: 120px;
        }
        #customContextMenu ul {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        #customContextMenu li {
            padding: 0.5rem 0.75rem;
            cursor: pointer;
            font-size: 0.875rem;
            color: #d1d5db; 
        }
        #customContextMenu li:hover {
            background-color: #4b5563; 
            color: #f3f4f6; 
        }


        canvas {
            border: 1px solid #4b5563; 
            border-radius: 0.5rem; 
            background-color: #000000; 
            display: block; 
        }
        h1 {
            font-size: 1.875rem; 
            font-weight: 600; 
            margin-bottom: 1.5rem; 
            text-align: center;
            color: #f3f4f6; 
        }
        h2 { 
            font-size: 1.1rem; 
            font-weight: 600; 
            margin-bottom: 0.5rem; 
            color: #e5e7eb; 
        }
        h3 { 
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #e5e7eb;
        }
        .figure-type-selector {
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .figure-type-selector label {
            font-size: 0.9rem;
            color: #d1d5db;
        }
        .figure-type-selector select {
            background-color: #4b5563;
            color: #e5e7eb;
            border: 1px solid #6b7280;
            border-radius: 0.25rem;
            padding: 0.25rem 0.5rem;
        }

        .controls {
            margin-top: 0.75rem; 
            display: grid; 
            grid-template-columns: auto 1fr; 
            gap: 0.4rem 0.8rem; 
            align-items: center;
            width: 100%;
            max-width: 300px; 
        }
        .controls label, .controls .checkbox-label {
            font-size: 0.8rem; 
            justify-self: start; 
            color: #d1d5db; 
        }
        .controls input[type="range"], .controls input[type="number"], .controls select, .controls .styled-button, .controls .preset-display-button {
            width: 100%; 
            justify-self: end;
            accent-color: #3b82f6; 
            background-color: #4b5563; 
            color: #e5e7eb; 
            border: 1px solid #6b7280; 
            border-radius: 0.25rem;
            padding: 0.1rem 0.25rem;
            box-sizing: border-box; 
        }
        .controls select {
            padding: 0.2rem 0.25rem; 
        }
        .controls .styled-button, .controls .preset-display-button { 
            background-color: #2563eb; 
            color: white;
            padding: 0.3rem 0.6rem;
            text-align: center;
            cursor: pointer;
            font-size: 0.8rem;
        }
        .controls .styled-button:hover, .controls .preset-display-button:hover {
            background-color: #1d4ed8; 
        }
        .controls input[type="color"] {
            width: 36px; 
            height: 28px; 
            border: 1px solid #4b5563; 
            padding: 0;
            border-radius: 0.25rem;
            cursor: pointer;
            justify-self: end; 
        }
         .controls .checkbox-container { 
            grid-column: span 2; 
            display: flex;
            align-items: center;
            gap: 0.4rem; 
        }
        .controls input[type="checkbox"] {
             accent-color: #3b82f6; 
        }
        /* .controls button { 
            display: none; 
        } */
        .controls h4 { 
            grid-column: span 2;
            font-size: 0.9rem;
            font-weight: 600;
            color: #9ca3af; 
            margin-top: 0.5rem;
            margin-bottom: 0.2rem;
            border-bottom: 1px solid #4b5563;
            padding-bottom: 0.1rem;
        }
        .slider-value-wrapper {
            position: relative;
            width: 100%; 
        }
        .slider-value-wrapper input[type="range"] {
            display: block; 
            width: 100%;
            margin: 0;
        }
        .slider-value-wrapper output {
            position: absolute;
            bottom: 22px; 
            background-color: #6b7280; 
            color: #e5e7eb;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7em;
            white-space: nowrap;
            pointer-events: none; 
            transform: translateX(-50%); 
            opacity: 0;
            transition: opacity 0.1s ease-in-out;
            z-index: 10; 
        }
        .slider-value-wrapper:hover output,
        .slider-value-wrapper input[type="range"]:active + output {
            opacity: 1;
        }
        
        #gradientSidebar {
            position: fixed;
            top: 5vh; 
            right: -350px; 
            width: 300px;
            height: auto; 
            max-height: 90vh; 
            background-color: #2d3748; 
            padding: 1rem;
            box-shadow: -5px 0 15px rgba(0,0,0,0.2);
            transition: right 0.3s ease-in-out;
            z-index: 1000;
            overflow-y: auto;
            border-radius: 0.5rem 0 0 0.5rem; 
        }
        #gradientSidebar.visible {
            right: 0;
        }
        #gradientSidebar h4 {
            color: #e5e7eb;
            margin-bottom: 1rem;
            text-align: center;
        }
        #gradientsCanvas {
            width: 100%;
            height: auto; 
            background-color: #1a202c; 
            border-radius: 0.25rem;
            cursor: pointer;
        }
        #closeGradientSidebar {
            background-color: #4a5568; 
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            cursor: pointer;
            display: block;
            width: 100%;
            margin-top: 1rem;
        }
        #closeGradientSidebar:hover {
            background-color: #2d3748; 
        }

    </style>
</head>
<body>
    <h1>Animated Geometric Patterns</h1>
    <div class="top-level-container">
        <div class="snapshot-strip-container">
            <h3>Snapshots</h3>
            <div class="snapshot-save-area-strip">
                <input type="text" id="snapshotNameInput" placeholder="Snapshot Name">
                <button id="saveSnapshotStripBtn" class="styled-button">Save Current</button>
            </div>
            <div id="snapshotImageStrip">
                </div>
        </div>
        <div class="content-wrapper">
            <div class="main-container">
                <div class="figure-slot-container">
                    <h2>Figure 1</h2>
                    <div class="figure-type-selector">
                        <label for="figure1Type">Type:</label>
                        <select id="figure1Type">
                            <option value="centeredCircles">Centered Circles</option>
                            <option value="rhodoneaCurve">Rhodonea Curve</option>
                            <option value="epitrochoid">Epitrochoid</option> 
                            <option value="hypotrochoid">Hypotrochoid</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <canvas id="figure1Canvas" width="300" height="300"></canvas>
                    <div class="controls" id="figure1Controls">
                        {/* Controls for Figure 1 */}
                    </div>
                </div>

                <div class="figure-slot-container">
                    <h2>Figure 2</h2>
                    <div class="figure-type-selector">
                        <label for="figure2Type">Type:</label>
                        <select id="figure2Type">
                            <option value="centeredCircles">Centered Circles</option>
                            <option value="rhodoneaCurve" selected>Rhodonea Curve</option>
                            <option value="epitrochoid">Epitrochoid</option>
                            <option value="hypotrochoid">Hypotrochoid</option>
                            <option value="none">None</option>
                        </select>
                    </div>
                    <canvas id="figure2Canvas" width="300" height="300"></canvas>
                    <div class="controls" id="figure2Controls">
                        {/* Controls for Figure 2 */}
                    </div>
                </div>

                <div class="figure-slot-container">
                    <h2>Figure 3</h2>
                    <div class="figure-type-selector">
                        <label for="figure3Type">Type:</label>
                        <select id="figure3Type">
                            <option value="centeredCircles">Centered Circles</option>
                            <option value="rhodoneaCurve">Rhodonea Curve</option>
                            <option value="epitrochoid">Epitrochoid</option>
                            <option value="hypotrochoid">Hypotrochoid</option>
                            <option value="none" selected>None</option>
                        </select>
                    </div>
                    <canvas id="figure3Canvas" width="300" height="300"></canvas>
                    <div class="controls" id="figure3Controls">
                        {/* Controls for Figure 3 */}
                    </div>
                </div>
            </div>

            <div class="overlay-container">
                <h3>Overlay</h3>
                <canvas id="combinedCanvas" width="600" height="600"></canvas>
                <div class="controls" id="combinedControls">
                     <label for="mainBlendingMode">Main Blending Mode:</label>
                     <select id="mainBlendingMode">
                        <option value="source-over">Normal</option>
                        <option value="lighter">Lighter (Additive)</option>
                        <option value="multiply">Multiply</option>
                        <option value="screen">Screen</option>
                        <option value="overlay">Overlay</option>
                        <option value="darken">Darken</option>
                        <option value="lighten">Lighten</option>
                        <option value="color-dodge">Color Dodge</option>
                        <option value="color-burn">Color Burn</option>
                        <option value="hard-light">Hard Light</option>
                        <option value="soft-light">Soft Light</option>
                        <option value="difference">Difference</option>
                        <option value="exclusion">Exclusion</option>
                        <option value="hue">Hue</option>
                        <option value="saturation">Saturation</option>
                        <option value="color">Color</option>
                        <option value="luminosity">Luminosity</option>
                     </select>
                </div>
            </div>
        </div>
    </div>

    <div id="gradientSidebar">
        <h4>Choose Preset Gradient</h4>
        <canvas id="gradientsCanvas"></canvas>
        <button id="closeGradientSidebar">Close</button>
    </div>

    <div id="customContextMenu">
        <ul>
            <li id="ctxMenuLoad">Load</li>
            <li id="ctxMenuRename">Rename</li>
            <li id="ctxMenuDelete">Delete</li>
        </ul>
    </div>

    <script>
        const figureParams = [{}, {}, {}]; 
        const figureCanvases = [];
        const figureContexts = [];

        const defaultCenteredCirclesParams = {
            type: 'centeredCircles',
            color: '#007bff', 
            baseLineWidth: 2, animateLineWidth: false, lineWidthAnimationSpeed: 0.2, currentLineWidth: 2, lineWidthAmplitudeFactor: 0.5,
            baseRotation: 0, animateRotation: false, reverseRotation: false, rotationSpeed: 0.1, currentRotation: 0,
            showCenterCircle: true, centerRadiusPercent: 50, numOuterCircles: 6,
            baseSizePercent: 75, animateSize: false, sizeAnimationSpeed: 0.2, currentSizePercent: 75, sizeAmplitude: 20,
            blendingMode: 'defer',
            fillLoops: false, fillType: 'solid', fillColor1: '#007bff', fillColor2: '#0056b3', fillOpacity: 1, 
            presetGradient: 'ocean' 
        };

        const defaultRhodoneaParams = {
            type: 'rhodoneaCurve',
            color: '#FF69B4', 
            baseLineWidth: 2, animateLineWidth: false, lineWidthAnimationSpeed: 0.2, currentLineWidth: 2, lineWidthAmplitudeFactor: 0.5,
            n: 3, d: 4,
            baseRotation: 0, animateRotation: false, reverseRotation: false, rotationSpeed: 0.1, currentRotation: 0,
            showCenterCircle: false, centerRadiusPercent: 50,
            baseSizePercent: 75, animateSize: false, sizeAnimationSpeed: 0.2, currentSizePercent: 75, sizeAmplitude: 20,
            steps: 1000, blendingMode: 'defer',
            fillLoops: false, fillType: 'solid', fillColor1: '#FF69B4', fillColor2: '#FFC0CB', fillOpacity: 1,
            presetGradient: 'sunset' 
        };

        const defaultEpitrochoidParams = {
            type: 'epitrochoid',
            color: '#28a745', 
            baseLineWidth: 2, animateLineWidth: false, lineWidthAnimationSpeed: 0.2, currentLineWidth: 2, lineWidthAmplitudeFactor: 0.5,
            R: 30, r: 10, d_param: 20, 
            baseRotation: 0, animateRotation: false, reverseRotation: false, rotationSpeed: 0.1, currentRotation: 0,
            baseSizePercent: 75, animateSize: false, sizeAnimationSpeed: 0.2, currentSizePercent: 75, sizeAmplitude: 20,
            steps: 1000, blendingMode: 'defer',
            fillLoops: false, fillType: 'solid', fillColor1: '#28a745', fillColor2: '#90EE90', fillOpacity: 1,
            presetGradient: 'forest'
        };

        const defaultHypotrochoidParams = {
            type: 'hypotrochoid',
            color: '#FFA500', 
            baseLineWidth: 2, animateLineWidth: false, lineWidthAnimationSpeed: 0.2, currentLineWidth: 2, lineWidthAmplitudeFactor: 0.5,
            R: 50, r: 20, d_param: 30, 
            baseRotation: 0, animateRotation: false, reverseRotation: false, rotationSpeed: 0.1, currentRotation: 0,
            baseSizePercent: 75, animateSize: false, sizeAnimationSpeed: 0.2, currentSizePercent: 75, sizeAmplitude: 20,
            steps: 1000, blendingMode: 'defer',
            fillLoops: false, fillType: 'solid', fillColor1: '#FFA500', fillColor2: '#FFD700', fillOpacity: 1,
            presetGradient: 'fire'
        };
        
        const FIGURE3_DEFAULT_COLOR = '#50BE71'; 

        const presetGradients = [
            { id: 'sunset', name: 'Sunset', stops: [{offset:0, color:'#FFD700'}, {offset:0.5, color:'#FF8C00'}, {offset:1, color:'#FF0000'}] },
            { id: 'ocean', name: 'Ocean', stops: [{offset:0, color:'#00BFFF'}, {offset:0.7, color:'#1E90FF'}, {offset:1, color:'#000080'}] },
            { id: 'forest', name: 'Forest', stops: [{offset:0, color:'#90EE90'}, {offset:0.5, color:'#2E8B57'}, {offset:1, color:'#006400'}] },
            { id: 'nebula', name: 'Nebula', stops: [{offset:0, color:'#DA70D6'}, {offset:0.3, color:'#8A2BE2'}, {offset:0.7, color:'#4B0082'}, {offset:1, color:'#000000'}] },
            { id: 'fire', name: 'Fire', stops: [{offset:0, color:'#FFFF00'}, {offset:0.2, color:'#FFD700'}, {offset:0.6, color:'#FF4500'}, {offset:1, color:'#8B0000'}] },
            { id: 'ice', name: 'Ice', stops: [{offset:0, color:'#E0FFFF'}, {offset:0.5, color:'#AFEEEE'}, {offset:1, color:'#7FFFD4'}] },
            { id: 'rose', name: 'Rose Petals', stops: [{offset:0, color:'#FFC0CB'}, {offset:0.6, color:'#FF69B4'}, {offset:1, color:'#DB7093'}] },
            { id: 'cosmic_lilac', name: 'Cosmic Lilac', stops: [{offset:0, color:'#483D8B'}, {offset:0.5, color:'#9370DB'}, {offset:1, color:'#FFC0CB'}] },
            { id: 'minty_spring', name: 'Minty Spring', stops: [{offset:0, color:'#3CB371'}, {offset:0.6, color:'#98FB98'}, {offset:1, color:'#F0FFF0'}] },
            { id: 'desert_mirage', name: 'Desert Mirage', stops: [{offset:0, color:'#F4A460'}, {offset:0.5, color:'#CD853F'}, {offset:0.8, color:'#A0522D'}, {offset:1, color:'#87CEEB'}] },
            { id: 'volcanic_ash', name: 'Volcanic Ash', stops: [{offset:0, color:'#2F4F4F'}, {offset:0.4, color:'#808080'}, {offset:0.7, color:'#FF4500'}, {offset:1, color:'#DC143C'}] },
            { id: 'coral_reef', name: 'Coral Reef', stops: [{offset:0, color:'#FF7F50'}, {offset:0.5, color:'#40E0D0'}, {offset:1, color:'#FFFFE0'}] },
            { id: 'arctic_dawn', name: 'Arctic Dawn', stops: [{offset:0, color:'#ADD8E6'}, {offset:0.4, color:'#B0E0E6'}, {offset:0.7, color:'#E6E6FA'}, {offset:1, color:'#FFFFFF'}] },
            { id: 'enchanted_forest', name: 'Enchanted Forest', stops: [{offset:0, color:'#006400'}, {offset:0.4, color:'#556B2F'}, {offset:0.7, color:'#20B2AA'}, {offset:1, color:'#008080'}] },
            { id: 'strawberry_kiwi', name: 'Strawberry Kiwi', stops: [{offset:0, color:'#FF4500'}, {offset:0.3, color:'#FFB6C1'}, {offset:0.7, color:'#32CD32'}, {offset:1, color:'#ADFF2F'}] },
            { id: 'vintage_wine', name: 'Vintage Wine', stops: [{offset:0, color:'#800000'}, {offset:0.5, color:'#B22222'}, {offset:0.8, color:'#DAA520'}, {offset:1, color:'#FFD700'}] },
            { id: 'galaxy_swirl', name: 'Galaxy Swirl', stops: [{offset:0, color:'#000033'}, {offset:0.3, color:'#4B0082'}, {offset:0.6, color:'#FF00FF'}, {offset:0.8, color:'#00FFFF'}, {offset:1, color:'#1E1E1E'}] },
            { id: 'emerald_isle', name: 'Emerald Isle', stops: [{offset:0, color:'#006A4E'}, {offset:0.25, color:'#00A86B'}, {offset:0.5, color:'#50C878'}, {offset:0.75, color:'#98FF98'}, {offset:1, color:'#C1FFC1'}] },
            { id: 'twilight_sky', name: 'Twilight Sky', stops: [{offset:0, color:'#191970'}, {offset:0.3, color:'#4682B4'}, {offset:0.6, color:'#B0C4DE'}, {offset:0.8, color:'#FFDAB9'}, {offset:1, color:'#FFA07A'}] },
            { id: 'autumn_leaves', name: 'Autumn Leaves', stops: [{offset:0, color:'#8B4513'}, {offset:0.25, color:'#A0522D'}, {offset:0.5, color:'#D2691E'}, {offset:0.75, color:'#FF8C00'}, {offset:1, color:'#FFD700'}] }
        ];


        let mainBlendingModeInputElem; 
        let overlayParams = {};
        let gradientSidebarElem;
        let gradientsCanvasElem;
        let gradientsCtxElem;
        let closeGradientSidebarButtonElem;
        let snapshotNameInput;
        let saveSnapshotStripBtn; 
        let snapshotImageStripDiv; 
        let customContextMenuElem; 
        let currentContextMenuSnapshotId = null; 


        let lastTimestamp = 0;
        let accumulatedTime = 0;
        let activeFigureIndexForGradientChoice = 0; 

        for (let i = 0; i < 3; i++) {
            figureCanvases[i] = document.getElementById(`figure${i+1}Canvas`);
            figureContexts[i] = figureCanvases[i].getContext('2d');
        }
        const combinedCanvas = document.getElementById('combinedCanvas');
        const combinedCtx = combinedCanvas.getContext('2d');
        

        function gcd(a, b) {
            if (b === 0) return a;
            return gcd(b, a % b);
        }
        
        function hexToRgba(hex, alpha) {
            if (!hex || hex.length < 7) return `rgba(0,0,0,${alpha})`; 
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            if (isNaN(r) || isNaN(g) || isNaN(b)) return `rgba(0,0,0,${alpha})`; 
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }


        function createLabel(forId, text) {
            const label = document.createElement('label');
            label.htmlFor = forId;
            label.textContent = text;
            return label;
        }

        function createRangeInput(id, min, max, value, step) {
            const wrapper = document.createElement('div');
            wrapper.className = 'slider-value-wrapper';
            const input = document.createElement('input');
            input.type = 'range';
            input.id = id;
            input.min = min;
            input.max = max;
            input.value = value;
            input.step = step;
            const output = document.createElement('output');
            output.htmlFor = id;
            output.id = `${id}-value`;
            output.textContent = value; 
            wrapper.appendChild(input);
            wrapper.appendChild(output);
            input.addEventListener('input', (event) => {
                updateSliderOutputPosition(event.target);
            });
            return wrapper;
        }
        
        function createNumberInput(id, min, max, value, step) {
            const input = document.createElement('input');
            input.type = 'number';
            input.id = id;
            input.min = min;
            input.max = max;
            input.value = value;
            input.step = step;
            return input;
        }

        function createColorInput(id, value) {
            const input = document.createElement('input');
            input.type = 'color';
            input.id = id;
            input.value = value;
            return input;
        }

        function createCheckbox(id, labelText, checked) {
            const container = document.createElement('div');
            container.className = 'checkbox-container';
            const input = document.createElement('input');
            input.type = 'checkbox';
            input.id = id;
            input.checked = checked;
            const label = document.createElement('label');
            label.htmlFor = id;
            label.className = 'checkbox-label';
            label.textContent = labelText;
            container.appendChild(input);
            container.appendChild(label);
            return container;
        }

        function createSelect(id, options, selectedValue) { 
            const select = document.createElement('select');
            select.id = id;
            options.forEach(opt => {
                const option = document.createElement('option');
                option.value = opt.value;
                option.textContent = opt.text; 
                if (opt.value === selectedValue) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
            return select;
        }
        
        function createButton(id, text, onClickHandler) { 
            const button = document.createElement('button');
            button.type = 'button';
            button.id = id;
            button.textContent = text;
            button.className = 'styled-button'; 
            button.addEventListener('click', onClickHandler);
            return button;
        }


        function createSubheading(text) {
            const h4 = document.createElement('h4');
            h4.textContent = text;
            return h4;
        }
        
        const blendingModeOptions = [
            { value: 'defer', text: 'Defer to Main' },
            { value: 'source-over', text: 'Normal' },
            { value: 'lighter', text: 'Lighter (Additive)' },
            { value: 'multiply', text: 'Multiply' },
            { value: 'screen', text: 'Screen' },
            { value: 'overlay', text: 'Overlay' },
            { value: 'darken', text: 'Darken' },
            { value: 'lighten', text: 'Lighten' },
            { value: 'color-dodge', text: 'Color Dodge' },
            { value: 'color-burn', text: 'Color Burn' },
            { value: 'hard-light', text: 'Hard Light' },
            { value: 'soft-light', text: 'Soft Light' },
            { value: 'difference', text: 'Difference' },
            { value: 'exclusion', text: 'Exclusion' },
            { value: 'hue', text: 'Hue' },
            { value: 'saturation', text: 'Saturation' },
            { value: 'color', text: 'Color' },
            { value: 'luminosity', text: 'Luminosity' }
        ];

        const fillTypeOptions = [ 
            { value: 'solid', text: 'Solid' },
            { value: 'linear', text: '2-Color Linear' },
            { value: 'radial', text: '2-Color Radial' },
            { value: 'preset', text: 'Preset Gradient' }
        ];
        
        function populateControls(figureIndex, figureType) {
            const controlsDiv = document.getElementById(`figure${figureIndex + 1}Controls`);
            controlsDiv.innerHTML = ''; 
            const params = figureParams[figureIndex]; 

            if (figureType === 'none') return; 

            controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-color`, 'Color:'));
            controlsDiv.appendChild(createColorInput(`figure${figureIndex+1}-color`, params.color));

            controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-blendingMode`, 'Blending Mode:'));
            controlsDiv.appendChild(createSelect(`figure${figureIndex+1}-blendingMode`, blendingModeOptions, params.blendingMode));

            controlsDiv.appendChild(createSubheading('Line Thickness'));
            controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-baseLineWidth`, 'Base:'));
            controlsDiv.appendChild(createRangeInput(`figure${figureIndex+1}-baseLineWidth`, 0.5, 40, params.baseLineWidth, 0.1, figureIndex));
            controlsDiv.appendChild(createCheckbox(`figure${figureIndex+1}-animateLineWidth`, 'Animate', params.animateLineWidth));
            controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-lineWidthAnimationSpeed`, 'Speed:'));
            controlsDiv.appendChild(createRangeInput(`figure${figureIndex+1}-lineWidthAnimationSpeed`, 0.01, 1, params.lineWidthAnimationSpeed, 0.01, figureIndex));
            
            controlsDiv.appendChild(createSubheading('Rotation'));
            controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-baseRotation`, 'Degrees:'));
            controlsDiv.appendChild(createRangeInput(`figure${figureIndex+1}-baseRotation`, 0, 360, params.baseRotation / (Math.PI / 180), 1, figureIndex));
            controlsDiv.appendChild(createCheckbox(`figure${figureIndex+1}-animateRotation`, 'Animate', params.animateRotation));
            controlsDiv.appendChild(createCheckbox(`figure${figureIndex+1}-reverseRotation`, 'Reverse', params.reverseRotation)); 
            controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-rotationSpeed`, 'Speed:'));
            controlsDiv.appendChild(createRangeInput(`figure${figureIndex+1}-rotationSpeed`, 0.01, 1, params.rotationSpeed, 0.01, figureIndex));

            controlsDiv.appendChild(createSubheading('Size'));
            controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-baseSizePercent`, 'Base Size:'));
            controlsDiv.appendChild(createRangeInput(`figure${figureIndex+1}-baseSizePercent`, 0, 100, params.baseSizePercent, 1, figureIndex));
            controlsDiv.appendChild(createCheckbox(`figure${figureIndex+1}-animateSize`, 'Animate', params.animateSize));
            controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-sizeAnimationSpeed`, 'Speed:'));
            controlsDiv.appendChild(createRangeInput(`figure${figureIndex+1}-sizeAnimationSpeed`, 0.01, 1, params.sizeAnimationSpeed, 0.01, figureIndex));

            // Fill Options (Common for all types that support it)
            if (figureType === 'rhodoneaCurve' || figureType === 'epitrochoid' || figureType === 'hypotrochoid' || figureType === 'centeredCircles') {
                controlsDiv.appendChild(createSubheading('Fill Options'));
                controlsDiv.appendChild(createCheckbox(`figure${figureIndex+1}-fillLoops`, 'Fill Shape', params.fillLoops));
                controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-fillType`, 'Fill Type:'));
                controlsDiv.appendChild(createSelect(`figure${figureIndex+1}-fillType`, fillTypeOptions, params.fillType));
                
                const choosePresetButtonContainer = document.createElement('div');
                choosePresetButtonContainer.id = `figure${figureIndex + 1}-choosePresetContainer`;
                choosePresetButtonContainer.style.gridColumn = 'span 2'; 
                choosePresetButtonContainer.style.marginTop = '0.25rem'; 
                const choosePresetButton = createButton(`figure${figureIndex+1}-choosePresetBtn`, 'Choose Preset Gradient...', () => {
                    activeFigureIndexForGradientChoice = figureIndex;
                    renderGradientStrips();
                    gradientSidebarElem.classList.add('visible');
                });
                choosePresetButtonContainer.appendChild(choosePresetButton);
                controlsDiv.appendChild(choosePresetButtonContainer); 
                
                const presetSelect = createSelect(`figure${figureIndex+1}-presetGradient`, presetGradients.map(g => ({ value: g.id, text: g.name })), params.presetGradient);
                presetSelect.style.display = 'none'; 
                controlsDiv.appendChild(presetSelect);


                const fillColor1Label = createLabel(`figure${figureIndex+1}-fillColor1`, 'Fill Color 1:');
                const fillColor1Input = createColorInput(`figure${figureIndex+1}-fillColor1`, params.fillColor1);
                controlsDiv.appendChild(fillColor1Label);
                controlsDiv.appendChild(fillColor1Input);

                const fillColor2Label = createLabel(`figure${figureIndex+1}-fillColor2`, 'Fill Color 2:');
                const fillColor2Input = createColorInput(`figure${figureIndex+1}-fillColor2`, params.fillColor2);
                controlsDiv.appendChild(fillColor2Label);
                controlsDiv.appendChild(fillColor2Input);
                
                controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-fillOpacity`, 'Fill Opacity:'));
                controlsDiv.appendChild(createRangeInput(`figure${figureIndex+1}-fillOpacity`, 0, 1, params.fillOpacity, 0.01, figureIndex));
            }


            controlsDiv.appendChild(createSubheading('Shape Details'));
            if (figureType === 'centeredCircles' || figureType === 'rhodoneaCurve') {
                 controlsDiv.appendChild(createCheckbox(`figure${figureIndex+1}-toggleCenterCircle`, 'Show Center Circle', params.showCenterCircle));
                 controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-centerRadiusPercent`, 'Center Circle Size:'));
                 controlsDiv.appendChild(createRangeInput(`figure${figureIndex+1}-centerRadiusPercent`, 0, 100, params.centerRadiusPercent, 1, figureIndex));
            }

            if (figureType === 'centeredCircles') {
                controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-numOuterCircles`, 'Outer Circles:'));
                controlsDiv.appendChild(createNumberInput(`figure${figureIndex+1}-numOuterCircles`, 2, 24, params.numOuterCircles, 1));
            } else if (figureType === 'rhodoneaCurve') {
                controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-n`, 'n (numerator):'));
                controlsDiv.appendChild(createNumberInput(`figure${figureIndex+1}-n`, 1, 100, params.n, 1));
                controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-d`, 'd (denominator):'));
                controlsDiv.appendChild(createNumberInput(`figure${figureIndex+1}-d`, 1, 100, params.d, 1));
            } else if (figureType === 'epitrochoid' || figureType === 'hypotrochoid') {
                controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-R`, 'R (Fixed Circle):'));
                controlsDiv.appendChild(createRangeInput(`figure${figureIndex+1}-R`, 1, 100, params.R, 1, figureIndex));
                controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-r`, 'r (Rolling Circle):'));
                controlsDiv.appendChild(createRangeInput(`figure${figureIndex+1}-r`, 1, 100, params.r, 1, figureIndex));
                controlsDiv.appendChild(createLabel(`figure${figureIndex+1}-d_param`, 'd (Distance):'));
                controlsDiv.appendChild(createRangeInput(`figure${figureIndex+1}-d_param`, 1, 150, params.d_param, 1, figureIndex));
            }
            
            if (figureType === 'rhodoneaCurve' || figureType === 'epitrochoid' || figureType === 'hypotrochoid' || figureType === 'centeredCircles') {
                updateFigureFillControlsVisibility(figureIndex);
            }
            
            addEventListenersToControls(figureIndex);
            setTimeout(() => { 
                controlsDiv.querySelectorAll('input[type="range"]').forEach(updateSliderOutputPosition);
            }, 0);
        }

        function updateFigureFillControlsVisibility(figureIndex) { 
            const prefix = `figure${figureIndex + 1}-`;
            const params = figureParams[figureIndex];
            if (params.type !== 'rhodoneaCurve' && params.type !== 'epitrochoid' && params.type !== 'hypotrochoid' && params.type !== 'centeredCircles') return;


            const showSolid = params.fillType === 'solid';
            const showGradientColors = params.fillType === 'linear' || params.fillType === 'radial';
            const showPresetButton = params.fillType === 'preset';

            const fillColor1El = document.getElementById(`${prefix}fillColor1`);
            const fillColor1LabelEl = fillColor1El?.previousElementSibling; 
            const fillColor2El = document.getElementById(`${prefix}fillColor2`);
            const fillColor2LabelEl = fillColor2El?.previousElementSibling; 
            const choosePresetContainerEl = document.getElementById(`${prefix}choosePresetContainer`); 
            
            if(fillColor1El) fillColor1El.style.display = (showSolid || showGradientColors) ? '' : 'none';
            if(fillColor1LabelEl) fillColor1LabelEl.style.display = (showSolid || showGradientColors) ? '' : 'none';
            if(fillColor2El) fillColor2El.style.display = showGradientColors ? '' : 'none';
            if(fillColor2LabelEl) fillColor2LabelEl.style.display = showGradientColors ? '' : 'none';
            
            if(choosePresetContainerEl) choosePresetContainerEl.style.display = showPresetButton ? 'grid' : 'none'; 
            
            if (showSolid && fillColor1LabelEl) {
                fillColor1LabelEl.textContent = 'Fill Color:';
            } else if (fillColor1LabelEl) {
                fillColor1LabelEl.textContent = 'Fill Color 1:';
            }
        }
        
        function updateSliderOutputPosition(slider) {
            const wrapper = slider.parentElement;
            if (!wrapper || !wrapper.classList.contains('slider-value-wrapper')) return;
            const output = wrapper.querySelector('output');
            if (output) {
                const value = parseFloat(slider.value);
                const min = parseFloat(slider.min);
                const max = parseFloat(slider.max);
                const percent = (max === min) ? 0 : (value - min) / (max - min); 
                const sliderWidth = slider.offsetWidth;
                const thumbWidth = 16; 
                let outputLeft = percent * (sliderWidth - thumbWidth) + (thumbWidth / 2); 
                
                output.textContent = value.toFixed(slider.step.includes('.') ? slider.step.split('.')[1].length : 0);
                output.style.left = `${outputLeft}px`;
            }
        }


        function addEventListenersToControls(figureIndex) {
            const prefix = `figure${figureIndex + 1}-`;
            const addListener = (id, eventType, handler) => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener(eventType, handler);
                    if (element.type === 'range') {
                        element.addEventListener('input', () => updateSliderOutputPosition(element));
                    }
                }
            };

            addListener(`${prefix}color`, 'input', () => updateFigureParams(figureIndex));
            addListener(`${prefix}blendingMode`, 'change', () => updateFigureParams(figureIndex)); 
            addListener(`${prefix}baseLineWidth`, 'input', () => updateFigureParams(figureIndex));
            addListener(`${prefix}animateLineWidth`, 'change', () => updateFigureParams(figureIndex));
            addListener(`${prefix}lineWidthAnimationSpeed`, 'input', () => updateFigureParams(figureIndex));
            addListener(`${prefix}baseRotation`, 'input', () => updateFigureParams(figureIndex));
            addListener(`${prefix}animateRotation`, 'change', () => updateFigureParams(figureIndex));
            addListener(`${prefix}reverseRotation`, 'change', () => updateFigureParams(figureIndex)); 
            addListener(`${prefix}rotationSpeed`, 'input', () => updateFigureParams(figureIndex));
            
            if (figureParams[figureIndex].type !== 'epitrochoid' && figureParams[figureIndex].type !== 'hypotrochoid') {
                addListener(`${prefix}toggleCenterCircle`, 'change', () => updateFigureParams(figureIndex));
                addListener(`${prefix}centerRadiusPercent`, 'input', () => updateFigureParams(figureIndex));
            }

            addListener(`${prefix}baseSizePercent`, 'input', () => updateFigureParams(figureIndex));
            addListener(`${prefix}animateSize`, 'change', () => updateFigureParams(figureIndex));
            addListener(`${prefix}sizeAnimationSpeed`, 'input', () => updateFigureParams(figureIndex));

            if (figureParams[figureIndex].type === 'centeredCircles' || figureParams[figureIndex].type === 'rhodoneaCurve' || figureParams[figureIndex].type === 'epitrochoid' || figureParams[figureIndex].type === 'hypotrochoid') {
                addListener(`${prefix}fillLoops`, 'change', () => updateFigureParams(figureIndex));
                addListener(`${prefix}fillType`, 'change', () => { 
                    updateFigureParams(figureIndex);
                    updateFigureFillControlsVisibility(figureIndex);
                });
                addListener(`${prefix}fillColor1`, 'input', () => updateFigureParams(figureIndex));
                addListener(`${prefix}fillColor2`, 'input', () => updateFigureParams(figureIndex));
                addListener(`${prefix}fillOpacity`, 'input', () => {
                    updateFigureParams(figureIndex);
                });
                
                if (figureParams[figureIndex].type === 'rhodoneaCurve') {
                    addListener(`${prefix}n`, 'input', () => updateFigureParams(figureIndex));
                    addListener(`${prefix}d`, 'input', () => updateFigureParams(figureIndex));
                } else if (figureParams[figureIndex].type === 'epitrochoid' || figureParams[figureIndex].type === 'hypotrochoid') {
                    addListener(`${prefix}R`, 'input', () => updateFigureParams(figureIndex));
                    addListener(`${prefix}r`, 'input', () => updateFigureParams(figureIndex));
                    addListener(`${prefix}d_param`, 'input', () => updateFigureParams(figureIndex));
                } else if (figureParams[figureIndex].type === 'centeredCircles') {
                     addListener(`${prefix}numOuterCircles`, 'input', () => updateFigureParams(figureIndex));
                }
            }
        }
        
        function updateFigureParams(figureIndex) {
            const params = figureParams[figureIndex];
            const prefix = `figure${figureIndex + 1}-`;

            if (params.type === 'none') return;

            params.color = document.getElementById(`${prefix}color`).value;
            params.blendingMode = document.getElementById(`${prefix}blendingMode`).value; 
            params.baseLineWidth = parseFloat(document.getElementById(`${prefix}baseLineWidth`).value);
            params.animateLineWidth = document.getElementById(`${prefix}animateLineWidth`).checked;
            params.lineWidthAnimationSpeed = parseFloat(document.getElementById(`${prefix}lineWidthAnimationSpeed`).value);
            params.baseRotation = parseInt(document.getElementById(`${prefix}baseRotation`).value) * Math.PI / 180;
            params.animateRotation = document.getElementById(`${prefix}animateRotation`).checked;
            params.reverseRotation = document.getElementById(`${prefix}reverseRotation`).checked; 
            params.rotationSpeed = parseFloat(document.getElementById(`${prefix}rotationSpeed`).value);
            
            if (params.type !== 'epitrochoid' && params.type !== 'hypotrochoid') { // CenteredCircles and Rhodonea can have center circle
                if(document.getElementById(`${prefix}toggleCenterCircle`)) { // Check if element exists
                    params.showCenterCircle = document.getElementById(`${prefix}toggleCenterCircle`).checked;
                    params.centerRadiusPercent = parseInt(document.getElementById(`${prefix}centerRadiusPercent`).value);
                }
            }

            params.baseSizePercent = parseInt(document.getElementById(`${prefix}baseSizePercent`).value);
            params.animateSize = document.getElementById(`${prefix}animateSize`).checked;
            params.sizeAnimationSpeed = parseFloat(document.getElementById(`${prefix}sizeAnimationSpeed`).value);

            if (params.type === 'centeredCircles' || params.type === 'rhodoneaCurve' || params.type === 'epitrochoid' || params.type === 'hypotrochoid') {
                if(document.getElementById(`${prefix}fillLoops`)){ // Check if fill controls exist
                    params.fillLoops = document.getElementById(`${prefix}fillLoops`).checked;
                    params.fillType = document.getElementById(`${prefix}fillType`).value;
                    params.fillColor1 = document.getElementById(`${prefix}fillColor1`).value;
                    params.fillColor2 = document.getElementById(`${prefix}fillColor2`).value;
                    params.fillOpacity = parseFloat(document.getElementById(`${prefix}fillOpacity`).value);
                    const presetSelect = document.getElementById(`${prefix}presetGradient`); 
                    if (presetSelect) params.presetGradient = presetSelect.value;
                }

                if (params.type === 'centeredCircles') {
                    params.numOuterCircles = parseInt(document.getElementById(`${prefix}numOuterCircles`).value);
                } else if (params.type === 'rhodoneaCurve') {
                    params.n = parseInt(document.getElementById(`${prefix}n`).value);
                    params.d = parseInt(document.getElementById(`${prefix}d`).value);
                    if (params.d === 0) params.d = 1; 
                } else { // Epitrochoid or Hypotrochoid
                    params.R = parseInt(document.getElementById(`${prefix}R`).value);
                    params.r = parseInt(document.getElementById(`${prefix}r`).value);
                    params.d_param = parseInt(document.getElementById(`${prefix}d_param`).value);
                    if (params.r === 0) params.r = 1; 
                }
            }
        }

        for (let i = 0; i < 3; i++) {
            document.getElementById(`figure${i+1}Type`).addEventListener('change', function() {
                const newType = this.value;
                const oldParams = { ...figureParams[i] };

                figureParams[i].type = newType;
                let defaultSpecificParams = {};
                if (newType === 'centeredCircles') {
                    defaultSpecificParams = JSON.parse(JSON.stringify(defaultCenteredCirclesParams));
                } else if (newType === 'rhodoneaCurve') {
                    defaultSpecificParams = JSON.parse(JSON.stringify(defaultRhodoneaParams));
                } else if (newType === 'epitrochoid') {
                    defaultSpecificParams = JSON.parse(JSON.stringify(defaultEpitrochoidParams));
                } else if (newType === 'hypotrochoid') {
                    defaultSpecificParams = JSON.parse(JSON.stringify(defaultHypotrochoidParams));
                } else { 
                    figureParams[i] = { type: 'none' }; 
                }
                
                if (newType !== 'none') {
                     figureParams[i] = { ...defaultSpecificParams, 
                                        animateRotation: oldParams.animateRotation !== undefined ? oldParams.animateRotation : defaultSpecificParams.animateRotation,
                                        reverseRotation: oldParams.reverseRotation !== undefined ? oldParams.reverseRotation : defaultSpecificParams.reverseRotation,
                                        rotationSpeed: oldParams.rotationSpeed !== undefined ? oldParams.rotationSpeed : defaultSpecificParams.rotationSpeed,
                                        baseRotation: oldParams.baseRotation !== undefined ? oldParams.baseRotation : defaultSpecificParams.baseRotation,
                                        animateSize: oldParams.animateSize !== undefined ? oldParams.animateSize : defaultSpecificParams.animateSize,
                                        sizeAnimationSpeed: oldParams.sizeAnimationSpeed !== undefined ? oldParams.sizeAnimationSpeed : defaultSpecificParams.sizeAnimationSpeed,
                                        baseSizePercent: oldParams.baseSizePercent !== undefined ? oldParams.baseSizePercent : defaultSpecificParams.baseSizePercent,
                                        animateLineWidth: oldParams.animateLineWidth !== undefined ? oldParams.animateLineWidth : defaultSpecificParams.animateLineWidth,
                                        lineWidthAnimationSpeed: oldParams.lineWidthAnimationSpeed !== undefined ? oldParams.lineWidthAnimationSpeed : defaultSpecificParams.lineWidthAnimationSpeed,
                                        baseLineWidth: oldParams.baseLineWidth !== undefined ? oldParams.baseLineWidth : defaultSpecificParams.baseLineWidth,
                                        color: oldParams.color !== undefined ? oldParams.color : defaultSpecificParams.color,
                                        blendingMode: oldParams.blendingMode !== undefined ? oldParams.blendingMode : 'defer',
                                        // Preserve fill options if switching between fillable types
                                        fillLoops: oldParams.fillLoops !== undefined ? oldParams.fillLoops : defaultSpecificParams.fillLoops,
                                        fillType: oldParams.fillType !== undefined ? oldParams.fillType : defaultSpecificParams.fillType,
                                        fillColor1: oldParams.fillColor1 !== undefined ? oldParams.fillColor1 : defaultSpecificParams.fillColor1,
                                        fillColor2: oldParams.fillColor2 !== undefined ? oldParams.fillColor2 : defaultSpecificParams.fillColor2,
                                        fillOpacity: oldParams.fillOpacity !== undefined ? oldParams.fillOpacity : defaultSpecificParams.fillOpacity,
                                        presetGradient: oldParams.presetGradient !== undefined ? oldParams.presetGradient : defaultSpecificParams.presetGradient,
                                        type: newType };
                }
                
                if (i === 2 && newType !== 'none' && (!oldParams.color || oldParams.color === defaultCenteredCirclesParams.color || oldParams.color === defaultRhodoneaParams.color || oldParams.color === defaultEpitrochoidParams.color || oldParams.color === defaultHypotrochoidParams.color) ) {
                    figureParams[i].color = FIGURE3_DEFAULT_COLOR;
                } else if (i === 2 && (newType === 'epitrochoid' || newType === 'hypotrochoid' || newType === 'centeredCircles')) { 
                     figureParams[i].color = FIGURE3_DEFAULT_COLOR;
                }


                populateControls(i, newType);
                if (newType !== 'none') {
                    updateFigureParams(i); 
                }
            });
        }
        
        function drawCenteredCirclesInternal(ctx, canvasWidth, canvasHeight, params) { 
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const currentOuterRadius = (params.currentSizePercent / 100) * (canvasWidth / 4); 

            ctx.lineWidth = params.currentLineWidth;
            ctx.save(); 
            ctx.translate(centerX, centerY);
            ctx.rotate(params.currentRotation); 
            ctx.translate(-centerX, -centerY);

            const figurePath = new Path2D(); 

            if (params.showCenterCircle) {
                const figureRadius = 2 * currentOuterRadius; 
                const actualCenterRadius = (params.centerRadiusPercent / 100) * figureRadius;
                if (actualCenterRadius > 0) {
                    figurePath.moveTo(centerX + actualCenterRadius, centerY); 
                    figurePath.arc(centerX, centerY, actualCenterRadius, 0, 2 * Math.PI);
                }
            }

            if (currentOuterRadius > 0 && params.numOuterCircles > 0) {
                for (let i = 0; i < params.numOuterCircles; i++) { 
                    const angle = (2 * Math.PI / params.numOuterCircles) * i; 
                    const circleX = centerX + currentOuterRadius * Math.cos(angle);
                    const circleY = centerY + currentOuterRadius * Math.sin(angle);
                    figurePath.moveTo(circleX + currentOuterRadius, circleY); 
                    figurePath.arc(circleX, circleY, currentOuterRadius, 0, 2 * Math.PI);
                }
            }
            
            if (params.fillLoops && (params.showCenterCircle || params.numOuterCircles > 0)) {
                let figureEffectiveRadius = 0;
                if (params.numOuterCircles > 0) {
                    figureEffectiveRadius = 2 * currentOuterRadius;
                } else if (params.showCenterCircle) {
                    const tempOuterRadiusForCalc = (params.baseSizePercent / 100) * (canvasWidth / 4); 
                    const figureRadius = 2 * tempOuterRadiusForCalc; 
                    figureEffectiveRadius = (params.centerRadiusPercent / 100) * figureRadius;
                }


                if (figureEffectiveRadius > 0) {
                    if (params.fillType === 'solid') {
                        ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                    } else if (params.fillType === 'linear') {
                        const gradient = ctx.createLinearGradient(centerX - figureEffectiveRadius, centerY, centerX + figureEffectiveRadius, centerY); 
                        gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                        gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                        ctx.fillStyle = gradient;
                    } else if (params.fillType === 'radial') {
                        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, figureEffectiveRadius); 
                        gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                        gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                        ctx.fillStyle = gradient;
                    } else if (params.fillType === 'preset') {
                        const preset = presetGradients.find(p => p.id === params.presetGradient);
                        if (preset) {
                            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, figureEffectiveRadius);
                            preset.stops.forEach(stop => {
                                gradient.addColorStop(stop.offset, hexToRgba(stop.color, params.fillOpacity));
                            });
                            ctx.fillStyle = gradient;
                        } else { 
                            ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                        }
                    }
                    ctx.fill(figurePath, "evenodd");
                }
            }

            ctx.strokeStyle = params.color; 
            ctx.stroke(figurePath); 
            ctx.restore(); 
        }

        function drawRhodoneaCurveInternal(ctx, canvasWidth, canvasHeight, params) {
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const current_scale_a = (params.currentSizePercent / 100) * (canvasWidth / 2);
            
            if (params.d === 0) return; 
            const kVal = params.n / params.d; 

            ctx.lineWidth = params.currentLineWidth;
            ctx.save(); 
            ctx.translate(centerX, centerY);
            ctx.rotate(params.currentRotation); 
            ctx.translate(-centerX, -centerY);

            const figurePath = new Path2D();
            const maxTheta = 2 * Math.PI * params.d;
            const numSteps = Math.max(1000, 200 * params.d); 
            let firstPoint = true;
            for (let i = 0; i <= numSteps; i++) {
                const theta = (i / numSteps) * maxTheta;
                const r = current_scale_a * Math.cos(kVal * theta);
                const x = centerX + r * Math.cos(theta);
                const y = centerY + r * Math.sin(theta);
                if (firstPoint) {
                    figurePath.moveTo(x, y);
                    firstPoint = false;
                } else {
                    figurePath.lineTo(x, y);
                }
            }
            figurePath.closePath(); 

            if (params.fillLoops && current_scale_a > 0) {
                if (params.fillType === 'solid') {
                    ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                } else if (params.fillType === 'linear') {
                    const gradient = ctx.createLinearGradient(centerX - current_scale_a, centerY, centerX + current_scale_a, centerY);
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'radial') {
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, current_scale_a);
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'preset') {
                    const preset = presetGradients.find(p => p.id === params.presetGradient);
                    if (preset) {
                        const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, current_scale_a);
                        preset.stops.forEach(stop => {
                            gradient.addColorStop(stop.offset, hexToRgba(stop.color, params.fillOpacity));
                        });
                        ctx.fillStyle = gradient;
                    } else { 
                        ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                    }
                }
                ctx.fill(figurePath, "evenodd");
            }
            
            if (current_scale_a > 0) {
                ctx.strokeStyle = params.color; 
                ctx.stroke(figurePath);
            }

            if (params.showCenterCircle && params.centerRadiusPercent >= 0) { 
                ctx.strokeStyle = params.color; 
                ctx.lineWidth = params.currentLineWidth; 
                ctx.beginPath(); // Separate path for center circle stroke
                const rhodoneaFigureRadius = current_scale_a;
                const centerCircleRadiusToDraw = (params.centerRadiusPercent / 100) * rhodoneaFigureRadius;
                ctx.arc(centerX, centerY, Math.min(centerCircleRadiusToDraw, canvasWidth / 2), 0, 2 * Math.PI);
                ctx.stroke();
            }
            ctx.restore(); 
        }

        function drawEpitrochoidInternal(ctx, canvasWidth, canvasHeight, params) {
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const sumOfRadiiForScale = params.R + params.r + params.d_param;
            if (sumOfRadiiForScale === 0) return;
            const scaleFactor = ((params.currentSizePercent / 100) * (canvasWidth / 2)) / sumOfRadiiForScale;
            
            const R_draw = params.R * scaleFactor;
            const r_draw = params.r * scaleFactor;
            const d_draw = params.d_param * scaleFactor;
            if (r_draw === 0) return;

            ctx.lineWidth = params.currentLineWidth;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(params.currentRotation);
            
            const figurePath = new Path2D();
            const commonDivisor = gcd(Math.round(params.R), Math.round(params.r));
            const maxTheta = 2 * Math.PI * (params.r / commonDivisor); 
            const numSteps = Math.max(1000, 300 * Math.abs(params.r / commonDivisor));

            let firstPoint = true;
            for (let i = 0; i <= numSteps; i++) {
                const t = (i / numSteps) * maxTheta;
                const x = (R_draw + r_draw) * Math.cos(t) - d_draw * Math.cos(((R_draw + r_draw) / r_draw) * t);
                const y = (R_draw + r_draw) * Math.sin(t) - d_draw * Math.sin(((R_draw + r_draw) / r_draw) * t);
                if (firstPoint) { figurePath.moveTo(x, y); firstPoint = false; } else { figurePath.lineTo(x, y); }
            }
            figurePath.closePath();

            if (params.fillLoops) { 
                if (params.fillType === 'solid') {
                    ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                } else if (params.fillType === 'linear') {
                    const gradient = ctx.createLinearGradient(-R_draw -r_draw -d_draw, 0, R_draw+r_draw+d_draw, 0); 
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'radial') {
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, Math.max(R_draw + r_draw, d_draw)); 
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'preset') {
                    const preset = presetGradients.find(p => p.id === params.presetGradient);
                    if (preset) {
                        const gradient = ctx.createRadialGradient(0,0,0, 0,0, Math.max(R_draw + r_draw, d_draw));
                        preset.stops.forEach(stop => {
                            gradient.addColorStop(stop.offset, hexToRgba(stop.color, params.fillOpacity));
                        });
                        ctx.fillStyle = gradient;
                    } else { 
                        ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                    }
                }
                ctx.fill(figurePath, "evenodd");
            }
            ctx.strokeStyle = params.color;
            ctx.stroke(figurePath);
            ctx.restore();
        }
        
        function drawHypotrochoidInternal(ctx, canvasWidth, canvasHeight, params) {
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const characteristicSizeForScale = Math.abs(params.R - params.r) + params.d_param; 
            if (characteristicSizeForScale === 0 && params.r === 0) return; 

            const scaleBase = characteristicSizeForScale > 0 ? characteristicSizeForScale : params.r;
            if (scaleBase === 0) return;

            const scaleFactor = ((params.currentSizePercent / 100) * (canvasWidth / 2)) / scaleBase;

            const R_draw = params.R * scaleFactor;
            const r_draw = params.r * scaleFactor;
            const d_draw = params.d_param * scaleFactor;
            if (r_draw === 0) return;

            ctx.lineWidth = params.currentLineWidth;
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(params.currentRotation);
            
            const figurePath = new Path2D(); 

            const commonDivisor = gcd(Math.round(params.R), Math.round(params.r));
            const maxTheta = 2 * Math.PI * (params.r / commonDivisor); 
            const numSteps = Math.max(1000, 300 * Math.abs(params.r / commonDivisor));

            let firstPoint = true;
            for (let i = 0; i <= numSteps; i++) {
                const t = (i / numSteps) * maxTheta;
                const x = (R_draw - r_draw) * Math.cos(t) + d_draw * Math.cos(((R_draw - r_draw) / r_draw) * t);
                const y = (R_draw - r_draw) * Math.sin(t) - d_draw * Math.sin(((R_draw - r_draw) / r_draw) * t);
                 if (firstPoint) { figurePath.moveTo(x, y); firstPoint = false; } else { figurePath.lineTo(x, y); }
            }
            figurePath.closePath();

            if (params.fillLoops) { 
                 if (params.fillType === 'solid') {
                    ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                } else if (params.fillType === 'linear') {
                    const gradient = ctx.createLinearGradient(-R_draw -d_draw, 0, R_draw+d_draw, 0); 
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'radial') {
                    const gradient = ctx.createRadialGradient(0,0,0, 0,0, Math.max(R_draw, d_draw)); 
                    gradient.addColorStop(0, hexToRgba(params.fillColor1, params.fillOpacity));
                    gradient.addColorStop(1, hexToRgba(params.fillColor2, params.fillOpacity));
                    ctx.fillStyle = gradient;
                } else if (params.fillType === 'preset') {
                    const preset = presetGradients.find(p => p.id === params.presetGradient);
                    if (preset) {
                         const gradient = ctx.createRadialGradient(0,0,0, 0,0, Math.max(R_draw, d_draw));
                        preset.stops.forEach(stop => {
                            gradient.addColorStop(stop.offset, hexToRgba(stop.color, params.fillOpacity));
                        });
                        ctx.fillStyle = gradient;
                    } else { 
                        ctx.fillStyle = hexToRgba(params.fillColor1, params.fillOpacity);
                    }
                }
                ctx.fill(figurePath, "evenodd");
            }
            ctx.strokeStyle = params.color;
            ctx.stroke(figurePath);
            ctx.restore();
        }


        function animateFigures(timestamp) {
            const deltaTime = (timestamp - lastTimestamp) / 1000; 
            lastTimestamp = timestamp;
            accumulatedTime += deltaTime;

            for (let i = 0; i < 3; i++) {
                const params = figureParams[i];
                const ctx = figureContexts[i];
                const canvas = figureCanvases[i];

                if (params.type === 'none') {
                    ctx.clearRect(0,0, canvas.width, canvas.height); 
                    continue;
                }

                if (params.animateRotation) {
                    const direction = params.reverseRotation ? -1 : 1;
                    params.currentRotation = params.baseRotation + (direction * accumulatedTime * params.rotationSpeed * 2 * Math.PI);
                } else {
                    params.currentRotation = params.baseRotation;
                }
                if (params.animateSize) {
                    const oscillation = params.sizeAmplitude * Math.sin(accumulatedTime * params.sizeAnimationSpeed * 2 * Math.PI);
                    params.currentSizePercent = params.baseSizePercent + oscillation;
                    params.currentSizePercent = Math.max(0, Math.min(100, params.currentSizePercent)); 
                } else {
                    params.currentSizePercent = params.baseSizePercent;
                }
                if (params.animateLineWidth) {
                    const amplitude = params.baseLineWidth * params.lineWidthAmplitudeFactor;
                    const oscillation = amplitude * Math.sin(accumulatedTime * params.lineWidthAnimationSpeed * 2 * Math.PI);
                    params.currentLineWidth = params.baseLineWidth + oscillation;
                    params.currentLineWidth = Math.max(0.1, params.currentLineWidth); 
                } else {
                    params.currentLineWidth = params.baseLineWidth;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (params.type === 'centeredCircles') {
                    drawCenteredCirclesInternal(ctx, canvas.width, canvas.height, params);
                } else if (params.type === 'rhodoneaCurve') {
                    drawRhodoneaCurveInternal(ctx, canvas.width, canvas.height, params);
                } else if (params.type === 'epitrochoid') {
                    drawEpitrochoidInternal(ctx, canvas.width, canvas.height, params);
                } else if (params.type === 'hypotrochoid') {
                    drawHypotrochoidInternal(ctx, canvas.width, canvas.height, params);
                }
            }
            
            combinedCtx.clearRect(0, 0, combinedCanvas.width, combinedCanvas.height);
            let firstActiveFigureDrawn = false;
            for (let i = 0; i < 3; i++) {
                const params = figureParams[i];
                if (params.type === 'none') continue;

                let effectiveBlendingMode = 'source-over';
                if (!firstActiveFigureDrawn) {
                    firstActiveFigureDrawn = true;
                } else {
                    if (params.blendingMode === 'defer') {
                        effectiveBlendingMode = overlayParams.mainBlendingMode;
                    } else {
                        effectiveBlendingMode = params.blendingMode;
                    }
                }
                
                combinedCtx.globalCompositeOperation = effectiveBlendingMode;
                
                if (params.type === 'centeredCircles') {
                    drawCenteredCirclesInternal(combinedCtx, combinedCanvas.width, combinedCanvas.height, params);
                } else if (params.type === 'rhodoneaCurve') {
                    drawRhodoneaCurveInternal(combinedCtx, combinedCanvas.width, combinedCanvas.height, params);
                } else if (params.type === 'epitrochoid') {
                    drawEpitrochoidInternal(combinedCtx, combinedCanvas.width, combinedCanvas.height, params);
                } else if (params.type === 'hypotrochoid') {
                    drawHypotrochoidInternal(combinedCtx, combinedCanvas.width, combinedCanvas.height, params);
                }
            }
            combinedCtx.globalCompositeOperation = 'source-over'; 

            requestAnimationFrame(animateFigures); 
        }
        
        function renderGradientStrips() {
            const stripHeight = 30;
            gradientsCanvasElem.height = presetGradients.length * stripHeight; 
            gradientsCanvasElem.width = 280; 
            gradientsCtxElem.clearRect(0, 0, gradientsCanvasElem.width, gradientsCanvasElem.height); 
            const currentParams = figureParams[activeFigureIndexForGradientChoice];
            const opacity = currentParams ? currentParams.fillOpacity : 0.3; 


            presetGradients.forEach((preset, index) => {
                const y = index * stripHeight; 
                const gradient = gradientsCtxElem.createLinearGradient(0, y, gradientsCanvasElem.width, y); 
                
                preset.stops.forEach(stop => {
                    gradient.addColorStop(stop.offset, hexToRgba(stop.color, opacity)); 
                });
                gradientsCtxElem.fillStyle = gradient; 
                gradientsCtxElem.fillRect(0, y, gradientsCanvasElem.width, stripHeight); 

                gradientsCtxElem.fillStyle = '#FFFFFF'; 
                gradientsCtxElem.font = '12px Inter';
                gradientsCtxElem.textAlign = 'left';
                gradientsCtxElem.textBaseline = 'middle';
                gradientsCtxElem.fillText(preset.name, 10, y + stripHeight / 2); 
            });
        }


        function resizeAndDrawAll() {
            let individualCanvasWidth = 300; 

            const figureSlotContainers = document.querySelectorAll('.figure-slot-container');
            if (figureSlotContainers.length > 0) {
                const firstSlotContainer = figureSlotContainers[0];
                const containerStyle = window.getComputedStyle(firstSlotContainer);
                const containerPaddingLeft = parseFloat(containerStyle.paddingLeft);
                const containerPaddingRight = parseFloat(containerStyle.paddingRight);
                let newWidth = firstSlotContainer.clientWidth - containerPaddingLeft - containerPaddingRight;
                individualCanvasWidth = Math.max(newWidth, 100); 

                figureSlotContainers.forEach((container, index) => {
                    const canvas = figureCanvases[index]; 
                    if(canvas) {
                        canvas.width = individualCanvasWidth;
                        canvas.height = individualCanvasWidth; 
                    }
                });
            }
            
            if (combinedCanvas) { 
                const overlayContainer = document.querySelector('.overlay-container');
                const containerStyle = window.getComputedStyle(overlayContainer);
                const containerPaddingLeft = parseFloat(containerStyle.paddingLeft);
                const containerPaddingRight = parseFloat(containerStyle.paddingRight);
                let combinedWidth = overlayContainer.clientWidth - containerPaddingLeft - containerPaddingRight;
                
                combinedWidth = Math.min(individualCanvasWidth * 2, combinedWidth);
                combinedWidth = Math.max(combinedWidth, 150); 

                combinedCanvas.width = combinedWidth; 
                combinedCanvas.height = combinedWidth; 
            }
            document.querySelectorAll('input[type="range"]').forEach(updateSliderOutputPosition);
        }

        window.onload = () => {
            mainBlendingModeInputElem = document.getElementById('mainBlendingMode');
            gradientSidebarElem = document.getElementById('gradientSidebar');
            gradientsCanvasElem = document.getElementById('gradientsCanvas');
            gradientsCtxElem = gradientsCanvasElem.getContext('2d');
            closeGradientSidebarButtonElem = document.getElementById('closeGradientSidebar');
            snapshotNameInput = document.getElementById('snapshotNameInput'); 
            saveSnapshotStripBtn = document.getElementById('saveSnapshotStripBtn'); 
            snapshotImageStripDiv = document.getElementById('snapshotImageStrip'); 
            customContextMenuElem = document.getElementById('customContextMenu');


            overlayParams.mainBlendingMode = mainBlendingModeInputElem.value;
            
            mainBlendingModeInputElem.addEventListener('change', () => { 
                overlayParams.mainBlendingMode = mainBlendingModeInputElem.value; 
            });

            closeGradientSidebarButtonElem.addEventListener('click', () => {
                gradientSidebarElem.classList.remove('visible');
            });
            
            gradientsCanvasElem.addEventListener('click', function(event) {
                const rect = gradientsCanvasElem.getBoundingClientRect();
                const y = event.offsetY; 
                const stripHeight = 30; 
                let clickedIndex = -1;

                for (let i = 0; i < presetGradients.length; i++) {
                    const stripTop = i * stripHeight;
                    const stripBottom = stripTop + stripHeight;
                    if (y >= stripTop && y < stripBottom) {
                        clickedIndex = i;
                        break;
                    }
                }

                if (clickedIndex !== -1) {
                    const selectedPresetId = presetGradients[clickedIndex].id;
                    figureParams[activeFigureIndexForGradientChoice].presetGradient = selectedPresetId;
                    
                    const presetSelectElement = document.getElementById(`figure${activeFigureIndexForGradientChoice + 1}-presetGradient`);
                    if(presetSelectElement) presetSelectElement.value = selectedPresetId;

                    updateFigureParams(activeFigureIndexForGradientChoice); 
                    // Sidebar remains open
                }
            });

            saveSnapshotStripBtn.addEventListener('click', saveSnapshot);
            renderSavedSnapshots();

            // Hide custom context menu on click outside
            document.addEventListener('click', (event) => {
                if (customContextMenuElem.style.display === 'block' && !customContextMenuElem.contains(event.target)) {
                    customContextMenuElem.style.display = 'none';
                }
            });
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    customContextMenuElem.style.display = 'none';
                }
            });


            for (let i = 0; i < 3; i++) {
                const typeSelector = document.getElementById(`figure${i+1}Type`);
                const initialType = typeSelector.value;
                figureParams[i].type = initialType; 

                let defaultSpecificParams = {};
                if (initialType === 'centeredCircles') {
                    defaultSpecificParams = JSON.parse(JSON.stringify(defaultCenteredCirclesParams));
                } else if (initialType === 'rhodoneaCurve') {
                    defaultSpecificParams = JSON.parse(JSON.stringify(defaultRhodoneaParams));
                } else if (initialType === 'epitrochoid') {
                    defaultSpecificParams = JSON.parse(JSON.stringify(defaultEpitrochoidParams));
                } else if (initialType === 'hypotrochoid') {
                    defaultSpecificParams = JSON.parse(JSON.stringify(defaultHypotrochoidParams));
                }
                
                figureParams[i] = { ...defaultSpecificParams, ...figureParams[i], type: initialType };

                if (i === 2 && initialType !== 'none') { 
                    figureParams[i].color = FIGURE3_DEFAULT_COLOR;
                } else if (i === 1 && initialType === 'centeredCircles') { 
                     figureParams[i].color = defaultCenteredCirclesParams.color; 
                } else if (i === 1 && initialType === 'rhodoneaCurve') { 
                     figureParams[i].color = defaultRhodoneaParams.color;
                } else if (i === 0 && initialType === 'rhodoneaCurve') { 
                     figureParams[i].color = defaultRhodoneaParams.color;
                } else if (i === 0 && initialType === 'epitrochoid') {
                     figureParams[i].color = defaultEpitrochoidParams.color;
                } else if (i === 1 && initialType === 'epitrochoid') {
                     figureParams[i].color = defaultEpitrochoidParams.color;
                } else if (i === 0 && initialType === 'hypotrochoid') {
                     figureParams[i].color = defaultHypotrochoidParams.color;
                } else if (i === 1 && initialType === 'hypotrochoid') {
                     figureParams[i].color = defaultHypotrochoidParams.color;
                }


                populateControls(i, initialType);
                if (initialType !== 'none') {
                    updateFigureParams(i); 
                }
            }
            
            resizeAndDrawAll(); 
            
            lastTimestamp = performance.now(); 
            requestAnimationFrame(animateFigures); 

            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    resizeAndDrawAll();
                    document.querySelectorAll('input[type="range"]').forEach(updateSliderOutputPosition);
                }, 100); 
            });
        };

        // --- Snapshot Functions ---
        function saveSnapshot() {
            let name = snapshotNameInput.value.trim();
            if (!name) {
                name = `Snapshot ${new Date().toLocaleString()}`;
            }

            const thumbnailCanvas = document.createElement('canvas');
            thumbnailCanvas.width = 80;
            thumbnailCanvas.height = 80;
            const thumbCtx = thumbnailCanvas.getContext('2d');
            thumbCtx.drawImage(combinedCanvas, 0, 0, 80, 80);
            const thumbnailDataUrl = thumbnailCanvas.toDataURL('image/jpeg', 0.5); 

            const snapshot = {
                id: Date.now(),
                name: name,
                timestamp: new Date().toLocaleString(),
                figureParams: JSON.parse(JSON.stringify(figureParams)), 
                overlayParams: JSON.parse(JSON.stringify(overlayParams)), 
                thumbnail: thumbnailDataUrl
            };

            let snapshots = JSON.parse(localStorage.getItem('geometricPatternSnapshots')) || [];
            snapshots.unshift(snapshot); 
            try {
                localStorage.setItem('geometricPatternSnapshots', JSON.stringify(snapshots));
                renderSavedSnapshots();
                snapshotNameInput.value = ''; 
            } catch (e) {
                console.error("Error saving to localStorage:", e);
                alert("Could not save snapshot. Storage might be full.");
            }
        }

        function loadSnapshot(snapshotId) {
            console.log(`Attempting to load snapshot ID: ${snapshotId}`);
            const snapshots = JSON.parse(localStorage.getItem('geometricPatternSnapshots')) || [];
            const loadedSnapshotData = snapshots.find(s => s.id === snapshotId);

            if (loadedSnapshotData) {
                console.log('Snapshot data found:', loadedSnapshotData);
                
                const loadedFigParams = JSON.parse(JSON.stringify(loadedSnapshotData.figureParams));
                for (let i = 0; i < loadedFigParams.length; i++) {
                    if (loadedFigParams[i]) {
                        figureParams[i] = loadedFigParams[i]; // Update the global array element
                    }
                }
                console.log('Global figureParams restored:', figureParams);

                overlayParams = JSON.parse(JSON.stringify(loadedSnapshotData.overlayParams));
                console.log('Global overlayParams restored:', overlayParams);
                
                if (mainBlendingModeInputElem) {
                    mainBlendingModeInputElem.value = overlayParams.mainBlendingMode;
                }
                
                for(let i=0; i<3; i++) {
                    console.log(`Restoring UI for Figure ${i+1}`);
                    const typeSelector = document.getElementById(`figure${i+1}Type`);
                    if (typeSelector) {
                        typeSelector.value = figureParams[i].type; 
                        console.log(`Figure ${i+1} type selector value set to: ${figureParams[i].type}`);
                    }
                    populateControls(i, figureParams[i].type); 
                    // updateFigureParams(i); // This is called implicitly by populateControls via event listeners if needed, or directly if not.
                                           // For loading, it's better to rely on populateControls using the already updated figureParams[i]
                }
                console.log('Snapshot load and UI update sequence complete.');
            } else {
                console.error("Snapshot not found:", snapshotId);
            }
        }

        function renameSnapshot(snapshotId) {
            console.log("Rename function called for ID:", snapshotId); 
            let snapshots = JSON.parse(localStorage.getItem('geometricPatternSnapshots')) || [];
            const snapshotIndex = snapshots.findIndex(s => s.id === snapshotId);
            if (snapshotIndex === -1) {
                console.error("Snapshot to rename not found:", snapshotId);
                return;
            }
            
            const newName = prompt("Enter new name for the snapshot:", snapshots[snapshotIndex].name);
            
            if (newName !== null) { // User clicked OK
                if (newName.trim() !== "") {
                    snapshots[snapshotIndex].name = newName.trim();
                    localStorage.setItem('geometricPatternSnapshots', JSON.stringify(snapshots));
                    renderSavedSnapshots();
                    console.log("Snapshot renamed and list updated.");
                } else {
                     console.log("Rename not performed: name was empty.");
                }
            } else {
                 console.log("Rename cancelled by user (prompt returned null).");
            }
        }

        function deleteSnapshot(snapshotId) {
            console.log("Delete function called for ID:", snapshotId); 
            let snapshots = JSON.parse(localStorage.getItem('geometricPatternSnapshots')) || [];
            const snapshotToDelete = snapshots.find(s => s.id === snapshotId);
            if (!snapshotToDelete) {
                 console.error("Snapshot to delete not found:", snapshotId);
                return;
            }
            
            if (confirm(`Are you sure you want to delete snapshot "${snapshotToDelete.name}"?`)) {
                console.log("Deletion confirmed for snapshot:", snapshotToDelete.name);
                snapshots = snapshots.filter(s => s.id !== snapshotId);
                localStorage.setItem('geometricPatternSnapshots', JSON.stringify(snapshots));
                renderSavedSnapshots();
            } else {
                console.log("Deletion cancelled by user for snapshot:", snapshotToDelete.name);
            }
        }

        function renderSavedSnapshots() {
            snapshotImageStripDiv.innerHTML = '';
            const snapshots = JSON.parse(localStorage.getItem('geometricPatternSnapshots')) || [];

            if (snapshots.length === 0) {
                const p = document.createElement('p');
                p.className = 'text-gray-400 text-sm text-center w-full';
                p.textContent = 'No snapshots yet.';
                snapshotImageStripDiv.appendChild(p);
                return;
            }

            snapshots.forEach(snapshot => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'snapshot-image-item';
                
                const img = document.createElement('img');
                img.src = snapshot.thumbnail;
                img.alt = snapshot.name;
                
                itemDiv.appendChild(img);

                itemDiv.addEventListener('dblclick', () => {
                    console.log(`Double-clicked snapshot ID: ${snapshot.id}, Name: ${snapshot.name}`);
                    loadSnapshot(snapshot.id);
                });
                itemDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    currentContextMenuSnapshotId = snapshot.id;
                    customContextMenuElem.style.top = `${e.pageY}px`; 
                    customContextMenuElem.style.left = `${e.pageX}px`; 
                    customContextMenuElem.style.display = 'block';
                });
                snapshotImageStripDiv.appendChild(itemDiv);
            });
        }

        // Context Menu Event Listeners
        document.getElementById('ctxMenuLoad').addEventListener('click', () => {
            const idToLoad = currentContextMenuSnapshotId; 
            customContextMenuElem.style.display = 'none'; 
            if (idToLoad) {
                console.log(`Context menu: Loading snapshot ID: ${idToLoad}`);
                loadSnapshot(idToLoad);
            }
        });
        document.getElementById('ctxMenuRename').addEventListener('click', () => {
            const idToRename = currentContextMenuSnapshotId;
            customContextMenuElem.style.display = 'none';
            if (idToRename) {
                console.log(`Context menu: Renaming snapshot ID: ${idToRename}`);
                renameSnapshot(idToRename);
            }
        });
        document.getElementById('ctxMenuDelete').addEventListener('click', () => {
            const idToDelete = currentContextMenuSnapshotId;
            customContextMenuElem.style.display = 'none';
            if (idToDelete) {
                console.log(`Context menu: Deleting snapshot ID: ${idToDelete}`);
                deleteSnapshot(idToDelete);
            }
        });


    </script>
</body>
</html>
