/**
 * Number Theory Utilities
 * Includes precomputed caches for expensive operations like Euler's Totient function.
 */

// Global cache for totient values
let totientCache = null;
let maxCached = 0;

/**
 * Initializes the Euler's Totient cache using a sieve.
 * @param {number} max - The maximum number to precompute for.
 */
export function initTotientCache(max) {
    if (totientCache && max <= maxCached) return;

    // If expanding, we could preserve old values, but for now just re-init if larger needed
    // or just checking if existing cache is sufficient.

    // Initialize array with identity (phi(i) = i)
    // Uint32Array is efficient
    totientCache = new Uint32Array(max + 1);
    for (let i = 0; i <= max; i++) {
        totientCache[i] = i;
    }

    // Sieve logic
    for (let p = 2; p <= max; p++) {
        if (totientCache[p] === p) { // p is prime
            for (let i = p; i <= max; i += p) {
                // phi(i) = phi(i) * (1 - 1/p) = phi(i) - phi(i)/p
                totientCache[i] -= totientCache[i] / p;
            }
        }
    }

    maxCached = max;
    console.log(`[NumberTheory] Initialized Totient Cache for max=${max}`);
}

/**
 * Returns Euler's Totient function phi(n).
 * @param {number} n 
 * @returns {number}
 */
export function getTotient(n) {
    if (!totientCache || n > maxCached) {
        // Fallback: Initialize with a default substantial size or exact needed
        initTotientCache(Math.max(n, 10000));
    }
    return totientCache[n];
}

/**
 * Modular Exponentiation
 * Returns (base^exp) % mod
 */
export function modularPow(base, exp, mod) {
    let result = 1;
    base = base % mod;
    while (exp > 0) {
        if (exp % 2 === 1) result = (result * base) % mod;
        exp = Math.floor(exp / 2);
        base = (base * base) % mod;
    }
    return result;
}

/**
 * Checks if number is prime (simple check)
 */
export function isPrime(num) {
    if (num <= 1) return false;
    for (let i = 2, s = Math.sqrt(num); i <= s; i++)
        if (num % i === 0) return false;
    return true;
}
/**
 * Finds the starting values (seeds) for all disjoint cycles (cosets) 
 * generated by multiplying by g modulo n.
 * Used for "Residue Designs" to verify full coverage.
 * @param {number} n - Modulo
 * @param {number} g - Generator
 * @returns {number[]} Array of seeds, one for each disjoint cycle.
 */
export function getDisjointCycleSeeds(n, g) {
    if (n < 2) return [0];

    // For Multiplicative Group visualization, we only want to show Disjoint Cycles (attractors).
    // Transients (pre-periods) should not be considered "cosets" as they merge into cycles.
    // If g is not coprime to n, we have a functional graph with rho-structures.
    // We want one seed per unique cycle.

    const visited = new Uint8Array(n); // 0 = unvisited, 1 = visited globally
    const seeds = [];

    // Always check 0? 0*g = 0. Cycle {0}.
    // If n > 1, 0 is a valid element.
    // Let's iterate 0 to n-1 to be complete.
    // (Previously started at 1, but 0 is valid in Z_n).
    for (let k = 0; k < n; k++) {
        if (visited[k]) continue;

        // Trace the path from k
        // We need to detect if this path:
        // A) Merges into an already visited cycle (Transient -> Old Cycle) => Discard
        // B) Forms a new cycle (Transient -> New Cycle) => Add representative of New Cycle

        let path = [];
        let curr = k;
        let hitOld = false;

        // Use a map for O(1) lookup in current path
        let pathSet = new Set();

        while (!visited[curr]) {
            pathSet.add(curr);
            path.push(curr);
            visited[curr] = 1; // Mark as visited globally so outer loop skips it

            curr = (curr * g) % n;

            if (pathSet.has(curr)) {
                // Cycle detected!
                // The cycle part is from `curr` to end of `path` (if we track full path) or just `curr` depends on detection.
                // In this logic, we found the loop closure.

                // Calculate length of the cycle we just found.
                // Since this is a functional graph component, we could have a tail + cycle.
                // But for pure multiplicative group units, it's just a cycle.
                // For non-units, we might have tails.
                // Our current `seeds` push only pushes the cycle start.
                // Let's count the cycle length.
                let cycleLen = 0;
                let scanner = curr;
                do {
                    cycleLen++;
                    scanner = (scanner * g) % n;
                } while (scanner !== curr && cycleLen < n);

                seeds.push({ seed: curr, length: cycleLen });
                break;
            }
        }

        if (!pathSet.has(curr)) {
            // We hit an OLD visited node.
            // This means the current path is a transient feeding into an existing component.
            // We discard this path (it adds no new cycles).
            // Example: 4 -> 12 (visited). Stop.
        }
    }

    // Sort seeds by cycle length descending
    // This ensures the "Main" rosette (largest group component) is Coset Index 0
    seeds.sort((a, b) => b.length - a.length);

    return seeds.map(s => s.seed);
}
