/**
 * Number Theory Utilities
 * Includes precomputed caches for expensive operations like Euler's Totient function.
 */

// Global cache for totient values
let totientCache = null;
let maxCached = 0;

/**
 * Initializes the Euler's Totient cache using a sieve.
 * @param {number} max - The maximum number to precompute for.
 */
export function initTotientCache(max) {
    if (totientCache && max <= maxCached) return;

    // If expanding, we could preserve old values, but for now just re-init if larger needed
    // or just checking if existing cache is sufficient.

    // Initialize array with identity (phi(i) = i)
    // Uint32Array is efficient
    totientCache = new Uint32Array(max + 1);
    for (let i = 0; i <= max; i++) {
        totientCache[i] = i;
    }

    // Sieve logic
    for (let p = 2; p <= max; p++) {
        if (totientCache[p] === p) { // p is prime
            for (let i = p; i <= max; i += p) {
                // phi(i) = phi(i) * (1 - 1/p) = phi(i) - phi(i)/p
                totientCache[i] -= totientCache[i] / p;
            }
        }
    }

    maxCached = max;
    console.log(`[NumberTheory] Initialized Totient Cache for max=${max}`);
}

/**
 * Returns Euler's Totient function phi(n).
 * @param {number} n 
 * @returns {number}
 */
export function getTotient(n) {
    if (!totientCache || n > maxCached) {
        // Fallback: Initialize with a default substantial size or exact needed
        initTotientCache(Math.max(n, 10000));
    }
    return totientCache[n];
}

/**
 * Modular Exponentiation
 * Returns (base^exp) % mod
 */
export function modularPow(base, exp, mod) {
    let result = 1;
    base = base % mod;
    while (exp > 0) {
        if (exp % 2 === 1) result = (result * base) % mod;
        exp = Math.floor(exp / 2);
        base = (base * base) % mod;
    }
    return result;
}

/**
 * Checks if number is prime (simple check)
 */
export function isPrime(num) {
    if (num <= 1) return false;
    for (let i = 2, s = Math.sqrt(num); i <= s; i++)
        if (num % i === 0) return false;
    return true;
}
/**
 * Finds the starting values (seeds) for all disjoint cycles (cosets) 
 * generated by multiplying by g modulo n.
 * Used for "Residue Designs" to verify full coverage.
 * @param {number} n - Modulo
 * @param {number} g - Generator
 * @returns {number[]} Array of seeds, one for each disjoint cycle.
 */
export function getDisjointCycleSeeds(n, g) {
    if (n < 2) return [0];

    // Track visited numbers.
    // We only care about 1..n-1 for multiplicative group usually, 
    // but 0 is its own trivial cycle (0 -> 0).
    // The paper usually implies 1..n-1.
    const visited = new Uint8Array(n); // 0 = unvisited
    const seeds = [];

    // Always include 0? Residue designs usually skip it or handled separately.
    // 0 * g = 0. It's a cycle of length 1.
    // Let's iterate 1 to n-1.
    for (let k = 1; k < n; k++) {
        if (visited[k]) continue;

        // k is a new cycle leader
        seeds.push(k);

        // Mark entire orbit as visited
        let val = k;
        while (!visited[val]) {
            visited[val] = 1;
            val = (val * g) % n;
            // If we hit a visited node (could be start, or merge into another cycle if not a group), stop.
            // In pure multiplicative group, orbits are disjoint loops.
            // In general residue designs (monoids), tails can merge. 
            // If we hit ALREADY visited (from previous cycle), we stop. 
            // If we hit current cycle start, we stop.
        }
    }

    return seeds;
}
